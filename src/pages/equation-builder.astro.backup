---
import Layout from '../layouts/Layout.astro';
---

<Layout 
  title="Equation Builder - Ashton Andrepont"
  description="Clean, simple visual equation builder - drag and connect nodes to create mathematical expressions"
>
  <section class="section">
    <h2>Visual Equation Builder</h2>
    <p>A clean, simple approach to visual equation building. Click nodes to add them, then click and drag to connect and build mathematical expressions.</p>
  </section>

  <!-- Clean equation builder interface -->
  <div class="equation-builder">
    <!-- Node Palette -->
    <div class="node-palette">
      <div class="palette-header">
        <h3>Node Library</h3>
        <div class="page-controls">
          <button class="page-btn" id="prev-page">‹</button>
          <span class="page-indicator" id="page-indicator">1 / 4</span>
          <button class="page-btn" id="next-page">›</button>
        </div>
      </div>
      
      <div class="palette-content" id="palette-content">
        <!-- Pages will be dynamically generated -->
      </div>
    </div>

    <!-- Canvas -->
    <div class="canvas" id="equation-canvas">
      <svg class="connections" id="connections-svg" width="100%" height="100%"></svg>
      
      <!-- Equation Display -->
      <div class="equation-display" id="equation-display">
        Click nodes above to add them to the canvas...
      </div>
    </div>
  </div>

  <!-- Property Sidebar -->
  <div class="sidebar" id="property-sidebar">
    <div class="sidebar-header">
      <h3 id="sidebar-title">Node Properties</h3>
      <button class="close-btn" id="close-sidebar">×</button>
    </div>
    <div class="sidebar-content" id="sidebar-content">
      Select a node to edit its properties
    </div>
  </div>
</Layout>

<script>
  // Clean Equation Builder - Vanilla JavaScript Implementation
  class CleanEquationBuilder {
    constructor() {
      this.nodes = new Map();
      this.connections = [];
      this.selectedNode = null;
      this.dragState = { isDragging: false, nodeId: null, offset: { x: 0, y: 0 } };
      this.connecting = { from: null, to: null };
      this.nodeCounter = 0;
      this.isEditingComponent = false;
      this.currentComponentId = null;
      this.originalNodePages = null;
      this.originalCurrentPage = 0;
      this.currentPage = 0;
      this.mainCanvasBackup = null;
      this.nodePages = [];
      
      this.canvas = document.getElementById('equation-canvas');
      this.sidebar = document.getElementById('property-sidebar');
      this.equationDisplay = document.getElementById('equation-display');
      this.connectionsSvg = document.getElementById('connections-svg');
      
      this.init();
    }

    init() {
      this.setupPalette();
      this.setupEventListeners();
    }
    
    setupPalette() {
      this.nodePages = [
        {
          title: 'Basic',
          nodes: [
            { type: 'number', label: 'Number' },
            { type: 'variable', label: 'Variable' },
            { type: 'add', label: '+' },
            { type: 'subtract', label: '−' },
            { type: 'multiply', label: '×' },
            { type: 'divide', label: '÷' },
            { type: 'output', label: 'Output' }
          ]
        },
        {
          title: 'Advanced Operations',
          nodes: [
            { type: 'power', label: '^' },
            { type: 'modulo', label: '%' },
            { type: 'sqrt', label: '√' },
            { type: 'abs', label: '|x|' },
            { type: 'log', label: 'log' },
            { type: 'ln', label: 'ln' }
          ]
        },
        {
          title: 'Trigonometry',
          nodes: [
            { type: 'sin', label: 'sin' },
            { type: 'cos', label: 'cos' },
            { type: 'tan', label: 'tan' }
          ]
        },
        {
          title: 'Constants',
          nodes: [
            { type: 'pi', label: 'π' },
            { type: 'e', label: 'e' }
          ]
        },
        {
          title: 'Comparison',
          nodes: [
            { type: 'equals', label: '=' },
            { type: 'greater', label: '>' },
            { type: 'less', label: '<' },
            { type: 'greaterEqual', label: '≥' },
            { type: 'lessEqual', label: '≤' },
            { type: 'notEqual', label: '≠' }
          ]
        },
        {
          title: 'Advanced',
          nodes: [
            { type: 'component', label: 'Component' },
            { type: 'conditional', label: 'If/Then' }
          ]
        }
      ];
      
      this.currentPage = 0;
      this.renderPalettePage();
    }
    
    renderPalettePage() {
      const page = this.nodePages[this.currentPage];
      const content = document.getElementById('palette-content');
      
      content.innerHTML = `
        <div class="palette-page">
          <div class="page-title">${page.title}</div>
          ${page.nodes.map(node => `
            <button class="palette-node" data-node-type="${node.type}">
              ${node.label}
            </button>
          `).join('')}
        </div>
      `;
      
      // Update page indicator
      document.getElementById('page-indicator').textContent = 
        `${this.currentPage + 1} / ${this.nodePages.length}`;
      
      // Update navigation button states
      document.getElementById('prev-page').disabled = this.currentPage === 0;
      document.getElementById('next-page').disabled = this.currentPage === this.nodePages.length - 1;
      
      // Add event listeners to new buttons
      content.querySelectorAll('.palette-node').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const nodeType = e.target.dataset.nodeType;
          const rect = this.canvas.getBoundingClientRect();
          
          // Create position that snaps to grid
          const gridSize = 20;
          const rawX = Math.random() * (rect.width - 150) + 50;
          const rawY = Math.random() * (rect.height - 150) + 50;
          
          const position = {
            x: Math.round(rawX / gridSize) * gridSize,
            y: Math.round(rawY / gridSize) * gridSize
          };
          
          this.addNode(nodeType, position);
        });
      });
    }

    setupEventListeners() {
      // Page navigation
      document.getElementById('prev-page').addEventListener('click', () => {
        if (this.currentPage > 0) {
          this.currentPage--;
          this.renderPalettePage();
        }
      });
      
      document.getElementById('next-page').addEventListener('click', () => {
        if (this.currentPage < this.nodePages.length - 1) {
          this.currentPage++;
          this.renderPalettePage();
        }
      });
      
      // Initialize palette event listeners
      this.updatePaletteEventListeners();
    }

    updatePaletteEventListeners() {
      // Clear existing listeners and add new ones for current page
      document.querySelectorAll('.palette-node').forEach(btn => {
        // Clone to remove existing listeners
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);
        
        // Add click listener
        newBtn.addEventListener('click', (e) => {
          const nodeType = e.target.dataset.nodeType;
          const rect = this.canvas.getBoundingClientRect();
          
          // Create position that snaps to grid
          const gridSize = 20;
          const rawX = Math.random() * (rect.width - 150) + 50;
          const rawY = Math.random() * (rect.height - 150) + 50;
          
          const position = {
            x: Math.round(rawX / gridSize) * gridSize,
            y: Math.round(rawY / gridSize) * gridSize
          };
          
          this.addNode(nodeType, position);
        });
      });

      // Canvas events
      this.canvas.addEventListener('click', (e) => {
        if (e.target === this.canvas || e.target === this.connectionsSvg) {
          this.deselectAll();
        }
      });

      // Sidebar close
      document.getElementById('close-sidebar').addEventListener('click', () => {
        this.closeSidebar();
      });

      // Global mouse events for dragging
      document.addEventListener('mousemove', this.handleMouseMove.bind(this));
      document.addEventListener('mouseup', this.handleMouseUp.bind(this));
    }

    generateId() {
      return `node-${++this.nodeCounter}-${Date.now()}`;
    }

    addNode(type, position) {
      const id = this.generateId();
      
      const nodeConfigs = {
        // Generators
        number: { label: '5', value: 5, inputs: [], outputs: ['out'] },
        variable: { label: 'x', variable: 'x', inputs: [], outputs: ['out'] },
        constant_pi: { label: 'π', value: Math.PI, inputs: [], outputs: ['out'] },
        constant_e: { label: 'e', value: Math.E, inputs: [], outputs: ['out'] },
        
        // Basic Operators
        add: { label: '+', inputs: ['in1', 'in2'], outputs: ['out'] },
        subtract: { label: '−', inputs: ['in1', 'in2'], outputs: ['out'] },
        multiply: { label: '×', inputs: ['in1', 'in2'], outputs: ['out'] },
        divide: { label: '÷', inputs: ['in1', 'in2'], outputs: ['out'] },
        power: { label: '^', inputs: ['base', 'exp'], outputs: ['out'] },
        modulo: { label: 'mod', inputs: ['in1', 'in2'], outputs: ['out'] },
        
        // Advanced Math
        sqrt: { label: '√', inputs: ['value', 'root'], outputs: ['out'] },
        log: { label: 'log', inputs: ['value', 'base'], outputs: ['out'] },
        ln: { label: 'ln', inputs: ['in'], outputs: ['out'] },
        abs: { label: '|x|', inputs: ['in'], outputs: ['out'] },
        
        // Trigonometry  
        sin: { label: 'sin', inputs: ['in'], outputs: ['out'] },
        cos: { label: 'cos', inputs: ['in'], outputs: ['out'] },
        tan: { label: 'tan', inputs: ['in'], outputs: ['out'] },
        
        // Comparison
        equals: { label: '=', inputs: ['in1', 'in2'], outputs: ['out'] },
        greater: { label: '>', inputs: ['in1', 'in2'], outputs: ['out'] },
        less: { label: '<', inputs: ['in1', 'in2'], outputs: ['out'] },
        
        // Component I/O (for sub-equation editing)
        componentInput: { label: 'Input', inputs: [], outputs: ['out'], componentIO: true },
        componentOutput: { label: 'Output', inputs: ['in'], outputs: [], componentIO: true },
        
        // Advanced Components
        component: { label: 'Component', inputs: [], outputs: [], customizable: true },
        conditional: { label: 'If/Then', inputs: ['value', 'condition', 'min', 'max'], outputs: ['true', 'false'] },
        
        // Output
        output: { label: 'Result', inputs: ['in'], outputs: [] }
      };

      const config = nodeConfigs[type];
      const node = {
        id,
        type,
        position,
        ...config
      };

      this.nodes.set(id, node);
      this.renderNode(node);
      this.updateEquation();
      
      // If we're on the main canvas and have a backup, update it
      if (!this.isEditingComponent && this.mainCanvasBackup) {
        this.mainCanvasBackup.nodes.set(id, node);
      }
      
      // Handle component I/O nodes - update parent component ports
      if (node.componentIO && this.isEditingComponent) {
        this.updateParentComponentPorts();
      }
    }

    renderNode(node) {
      const nodeEl = document.createElement('div');
      nodeEl.className = `node node-${node.type}`;
      nodeEl.id = node.id;
      
      // Add special styling for advanced components
      if (node.type === 'component') {
        nodeEl.classList.add('node-component');
      } else if (node.type === 'conditional') {
        nodeEl.classList.add('node-conditional');
      } else if (node.type === 'componentInput') {
        nodeEl.classList.add('node-component-input');
      } else if (node.type === 'componentOutput') {
        nodeEl.classList.add('node-component-output');
      }
      
      // Explicit positioning and base styles to ensure visibility
      nodeEl.style.cssText = `
        position: absolute;
        left: ${node.position.x}px;
        top: ${node.position.y}px;
        min-width: 80px;
        padding: 8px 12px;
        background: white;
        border: 2px solid #cbd5e1;
        border-radius: 6px;
        cursor: move;
        user-select: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        font-size: 14px;
        font-weight: 500;
        z-index: 10;
        display: block;
      `;
      
      // Special handling for component nodes
      if (node.type === 'component') {
        nodeEl.innerHTML = `
          <div class="node-content">
            ${node.label}
          </div>
          ${node.inputs.map((input, i) => `
            <div class="port input-port" data-port="${input}" data-node="${node.id}" data-port-index="${i}" data-total-ports="${node.inputs.length}" data-tooltip="${this.getPortLabel(node.type, input, 'input')}" style="position: absolute; left: -7px; width: 12px; height: 12px; background: #10b981; border: 2px solid white; border-radius: 50%; cursor: crosshair; z-index: 30; pointer-events: auto;"></div>
          `).join('')}
          ${node.outputs.map((output, i) => `
            <div class="port output-port" data-port="${output}" data-node="${node.id}" data-port-index="${i}" data-total-ports="${node.outputs.length}" data-tooltip="${this.getPortLabel(node.type, output, 'output')}" style="position: absolute; right: -7px; width: 12px; height: 12px; background: #f59e0b; border: 2px solid white; border-radius: 50%; cursor: crosshair; z-index: 30; pointer-events: auto;"></div>
          `).join('')}
        `;
      } else {
        nodeEl.innerHTML = `
          <div class="node-content">${node.label}</div>
          ${node.inputs.map((input, i) => `
            <div class="port input-port" data-port="${input}" data-node="${node.id}" data-port-index="${i}" data-total-ports="${node.inputs.length}" data-tooltip="${this.getPortLabel(node.type, input, 'input')}" style="position: absolute; left: -7px; width: 12px; height: 12px; background: #10b981; border: 2px solid white; border-radius: 50%; cursor: crosshair; z-index: 30; pointer-events: auto;"></div>
          `).join('')}
          ${node.outputs.map((output, i) => `
            <div class="port output-port" data-port="${output}" data-node="${node.id}" data-port-index="${i}" data-total-ports="${node.outputs.length}" data-tooltip="${this.getPortLabel(node.type, output, 'output')}" style="position: absolute; right: -7px; width: 12px; height: 12px; background: #f59e0b; border: 2px solid white; border-radius: 50%; cursor: crosshair; z-index: 30; pointer-events: auto;"></div>
          `).join('')}
        `;
      }
      
      // Add event listeners
      nodeEl.addEventListener('mousedown', (e) => this.handleNodeMouseDown(e, node.id));
      nodeEl.addEventListener('click', (e) => {
        e.stopPropagation();
        this.selectNode(node.id);
      });



      // Port click events with proper event handling
      nodeEl.querySelectorAll('.port').forEach(port => {
        port.addEventListener('mousedown', (e) => {
          e.stopPropagation(); // Prevent node drag from starting
          e.preventDefault();
        });
        
        port.addEventListener('mouseenter', (e) => {
          port.style.transform = 'scale(1.4)';
          port.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.4)';
          
          // Create and show tooltip
          this.showTooltip(e, port.getAttribute('data-tooltip'));
        });
        
        port.addEventListener('mouseleave', (e) => {
          if (!this.connecting.from) {
            port.style.transform = 'scale(1)';
            port.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.3)';
          }
          
          // Hide tooltip
          this.hideTooltip();
        });
        
        port.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();
          this.handlePortClick(port.dataset.port, port.dataset.node, port.classList.contains('output-port'));
        });
      });

      this.canvas.appendChild(nodeEl);
      
      // Position ports evenly after node is rendered
      this.positionPortsEvenly(nodeEl, node);
    }

    getPortLabel(nodeType, portName, portType) {
      const portLabels = {
        // Basic nodes
        number: { out: 'Number Value' },
        variable: { out: 'Variable Value' },
        output: { in: 'Final Result' },
        
        // Arithmetic  
        add: { in1: 'First Number', in2: 'Second Number', out: 'Sum' },
        subtract: { in1: 'Minuend', in2: 'Subtrahend', out: 'Difference' },
        multiply: { in1: 'Multiplicand', in2: 'Multiplier', out: 'Product' },
        divide: { in1: 'Dividend', in2: 'Divisor', out: 'Quotient' },
        power: { base: 'Base Number', exp: 'Exponent', out: 'Result' },
        modulo: { in1: 'Dividend', in2: 'Modulus', out: 'Remainder' },
        
        // Advanced Math
        sqrt: { value: 'Value to Root', root: 'Root Degree (default: 2)', out: 'Root Result' },
        log: { value: 'Value for Log', base: 'Log Base (default: 10)', out: 'Logarithm' },
        ln: { in: 'Value for Natural Log', out: 'Natural Logarithm' },
        abs: { in: 'Value for Absolute', out: 'Absolute Value' },
        
        // Trigonometry
        sin: { in: 'Angle (radians)', out: 'Sine' },
        cos: { in: 'Angle (radians)', out: 'Cosine' },
        tan: { in: 'Angle (radians)', out: 'Tangent' },
        
        // Constants
        pi: { out: 'Pi (π ≈ 3.14159)' },
        e: { out: 'Euler Number (e ≈ 2.71828)' },
        
        // Comparison
        equals: { in1: 'Left Value', in2: 'Right Value', out: 'Equality (1/0)' },
        greater: { in1: 'Left Value', in2: 'Right Value', out: 'Greater Than (1/0)' },
        less: { in1: 'Left Value', in2: 'Right Value', out: 'Less Than (1/0)' },
        greaterEqual: { in1: 'Left Value', in2: 'Right Value', out: 'Greater/Equal (1/0)' },
        lessEqual: { in1: 'Left Value', in2: 'Right Value', out: 'Less/Equal (1/0)' },
        notEqual: { in1: 'Left Value', in2: 'Right Value', out: 'Not Equal (1/0)' },
        
        // Component I/O
        componentInput: { out: 'Input Data to Component' },
        componentOutput: { in: 'Result from Component Logic' },
        
        // Advanced Components
        component: { out: 'Component Output' },
        conditional: { 
          value: 'Value to Check', 
          condition: 'Condition Type', 
          min: 'Minimum Range', 
          max: 'Maximum Range', 
          true: 'If Condition Met', 
          false: 'If Condition Failed' 
        }
      };
      
      const nodeLabels = portLabels[nodeType];
      if (!nodeLabels) return `${portType}: ${portName}`;
      
      const label = nodeLabels[portName];
      return label ? `${portType}: ${label}` : `${portType}: ${portName}`;
    };

    showTooltip(event, text) {
      // Remove existing tooltip
      this.hideTooltip();
      
      const tooltip = document.createElement('div');
      tooltip.id = 'port-tooltip';
      tooltip.textContent = text;
      tooltip.style.cssText = `
        position: fixed;
        background: #1f2937;
        color: white;
        padding: 6px 10px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
        pointer-events: none;
        z-index: 1000;
        white-space: nowrap;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        left: ${event.clientX + 10}px;
        top: ${event.clientY - 30}px;
      `;
      
      document.body.appendChild(tooltip);
    }

    hideTooltip() {
      const existing = document.getElementById('port-tooltip');
      if (existing) {
        existing.remove();
      }
    }

    openComponentEditor(nodeId) {
      // Prevent entering component editing mode if already editing
      if (this.isEditingComponent) {
        return;
      }
      
      // Enter component editing mode in main canvas
      this.isEditingComponent = true;
      this.currentComponentId = nodeId;
      
      // Backup main canvas state
      this.mainCanvasBackup = {
        nodes: new Map(this.nodes),
        connections: [...this.connections]
      };
      
      // Store original palette pages and switch to component palette
      this.originalNodePages = this.nodePages;
      this.originalCurrentPage = this.currentPage;
      
      // Set component-specific node palette - full access to all tools
      this.nodePages = [
        {
          title: 'Component I/O',
          nodes: [
            { type: 'componentInput', label: 'Input' },
            { type: 'componentOutput', label: 'Output' }
          ]
        },
        {
          title: 'Basic',
          nodes: [
            { type: 'number', label: 'Number' },
            { type: 'variable', label: 'Variable' },
            { type: 'add', label: '+' },
            { type: 'subtract', label: '−' },
            { type: 'multiply', label: '×' },
            { type: 'divide', label: '÷' }
          ]
        },
        {
          title: 'Advanced Operations',
          nodes: [
            { type: 'power', label: '^' },
            { type: 'modulo', label: '%' },
            { type: 'sqrt', label: '√' },
            { type: 'abs', label: '|x|' },
            { type: 'log', label: 'log' },
            { type: 'ln', label: 'ln' }
          ]
        },
        {
          title: 'Trigonometry',
          nodes: [
            { type: 'sin', label: 'sin' },
            { type: 'cos', label: 'cos' },
            { type: 'tan', label: 'tan' }
          ]
        },
        {
          title: 'Constants',
          nodes: [
            { type: 'pi', label: 'π' },
            { type: 'e', label: 'e' }
          ]
        },
        {
          title: 'Comparison',
          nodes: [
            { type: 'equals', label: '=' },
            { type: 'greater', label: '>' },
            { type: 'less', label: '<' },
            { type: 'greaterEqual', label: '≥' },
            { type: 'lessEqual', label: '≤' },
            { type: 'notEqual', label: '≠' }
          ]
        }
      ];
      this.currentPage = 0;
      
      // Clear main canvas and show component editing UI
      this.clearCanvas();
      this.setComponentEditingMode(true);
      this.renderPalettePage();
      this.showComponentEditingOverlay(nodeId);
      
      // Initialize component workspace data if needed
      if (!window.componentData) {
        window.componentData = {};
      }
      if (!window.componentData[nodeId]) {
        window.componentData[nodeId] = {
          nodes: new Map(),
          connections: [],
          nodeCounter: 0
        };
      }
      
      // Load component's existing nodes if any
      this.loadComponentNodes(nodeId);
    }

    setComponentEditingMode(enabled) {
      // Change canvas background to distinguish component editing mode
      if (enabled) {
        this.canvas.style.background = `
          linear-gradient(90deg, rgba(139, 69, 19, 0.1) 0px, transparent 1px),
          linear-gradient(rgba(139, 69, 19, 0.1) 0px, transparent 1px),
          linear-gradient(45deg, rgba(139, 69, 19, 0.05) 25%, transparent 25%),
          linear-gradient(-45deg, rgba(139, 69, 19, 0.05) 25%, transparent 25%)
        `;
        this.canvas.style.backgroundSize = '20px 20px, 20px 20px, 40px 40px, 40px 40px';
      } else {
        // Restore original background
        this.canvas.style.background = `
          linear-gradient(90deg, rgba(99, 102, 241, 0.05) 0px, transparent 1px),
          linear-gradient(rgba(99, 102, 241, 0.05) 0px, transparent 1px)
        `;
        this.canvas.style.backgroundSize = '20px 20px';
      }
    }

    showComponentEditingOverlay(nodeId) {
      // Add component editing header overlay
      const existingOverlay = document.getElementById('component-editing-overlay');
      if (existingOverlay) existingOverlay.remove();
      
      const overlay = document.createElement('div');
      overlay.id = 'component-editing-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: #3b82f6;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        display: flex;
        align-items: center;
        gap: 16px;
        z-index: 1000;
      `;
      
      const node = Array.from(this.nodes.values()).find(n => n.id === nodeId);
      const componentName = node ? (node.customName || node.label) : 'Component';
      
      overlay.innerHTML = `
        <span style="font-weight: 600;">Editing: ${componentName}</span>
        <input type="text" id="comp-name-input" value="${componentName}" placeholder="Component Name" style="
          padding: 4px 8px;
          border: none;
          border-radius: 4px;
          font-size: 14px;
          width: 150px;
        ">
        <button id="save-component" style="
          background: #10b981;
          color: white;
          border: none;
          padding: 6px 12px;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 500;
        ">Save</button>
        <button id="cancel-component-edit" style="
          background: #ef4444;
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 600;
          font-size: 14px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        ">Exit Component</button>
      `;
      
      document.body.appendChild(overlay);
      
      // Add event listeners
      document.getElementById('save-component').addEventListener('click', (e) => {
        e.preventDefault();
        this.saveComponentAndExit(nodeId);
      });
      
      document.getElementById('cancel-component-edit').addEventListener('click', (e) => {
        e.preventDefault();
        this.exitComponentEditingMode();
      });
      
      // Allow Enter key to save component name
      document.getElementById('comp-name-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          this.saveComponentAndExit(nodeId);
        }
      });
    }

    clearCanvas() {
      // Clear all nodes from main canvas
      const existingNodes = document.querySelectorAll('#equation-canvas > div');
      existingNodes.forEach(node => node.remove());
      
      // Clear connections
      this.connectionsSvg.innerHTML = '';
    }

    loadComponentNodes(nodeId) {
      const compData = window.componentData[nodeId];
      if (!compData) return;
      
      // Clear current nodes and load component's nodes
      this.nodes = new Map(compData.nodes);
      
      // Render component's nodes in main canvas
      compData.nodes.forEach(node => {
        this.renderNode(node);
      });
      
      // Restore component's connections
      this.connections = [...compData.connections];
      this.updateConnections();
    }

    saveComponentAndExit(nodeId) {
      // Save current canvas state to component data
      const compData = window.componentData[nodeId];
      compData.nodes = new Map(this.nodes);
      compData.connections = [...this.connections];
      
      // Update component name in the backed up main canvas
      const newName = document.getElementById('comp-name-input').value || 'Component';
      const backupNode = this.mainCanvasBackup.nodes.get(nodeId);
      if (backupNode) {
        backupNode.customName = newName;
        backupNode.label = newName;
      }
      
      this.exitComponentEditingMode();
    }

    exitComponentEditingMode() {
      // Update component ports before exiting
      const componentId = this.currentComponentId;
      if (componentId) {
        this.updateComponentPortsInBackup(componentId);
      }
      
      // Exit component editing mode
      this.isEditingComponent = false;
      this.currentComponentId = null;
      
      // Restore original palette
      this.nodePages = this.originalNodePages;
      this.currentPage = this.originalCurrentPage;
      this.renderPalettePage();
      
      // Restore canvas background
      this.setComponentEditingMode(false);
      
      // Clear canvas and restore main nodes
      this.clearCanvas();
      this.loadMainNodes();
      
      // Remove overlay
      const overlay = document.getElementById('component-editing-overlay');
      if (overlay) overlay.remove();
    }

    loadMainNodes() {
      // Restore main canvas nodes and connections from stored data
      if (this.mainCanvasBackup) {
        // Restore nodes
        this.nodes = new Map(this.mainCanvasBackup.nodes);
        this.mainCanvasBackup.nodes.forEach(node => {
          this.renderNode(node);
        });
        
        // Restore connections
        this.connections = [...this.mainCanvasBackup.connections];
      }
      
      // Update visual connections and refresh calculations
      this.updateConnections();
      this.updateEquation(); // Auto-update component calculations after saving
    }




















    
    positionPortsEvenly(nodeEl, node) {
      const nodeRect = nodeEl.getBoundingClientRect();
      const nodeHeight = nodeRect.height;
      
      // Position input ports evenly along left side
      const inputPorts = nodeEl.querySelectorAll('.input-port');
      inputPorts.forEach((port, i) => {
        const totalPorts = inputPorts.length;
        if (totalPorts === 1) {
          port.style.top = `${nodeHeight / 2 - 6}px`; // Center single port (6px = half port height)
        } else {
          const spacing = nodeHeight / (totalPorts + 1);
          port.style.top = `${(i + 1) * spacing - 6}px`; // Evenly space ports
        }
      });
      
      // Position output ports evenly along right side
      const outputPorts = nodeEl.querySelectorAll('.output-port');
      outputPorts.forEach((port, i) => {
        const totalPorts = outputPorts.length;
        if (totalPorts === 1) {
          port.style.top = `${nodeHeight / 2 - 6}px`; // Center single port
        } else {
          const spacing = nodeHeight / (totalPorts + 1);
          port.style.top = `${(i + 1) * spacing - 6}px`; // Evenly space ports
        }
      });
    }

    handleNodeMouseDown(e, nodeId) {
      e.preventDefault();
      const nodeEl = document.getElementById(nodeId);
      const rect = nodeEl.getBoundingClientRect();
      
      this.dragState = {
        isDragging: true,
        nodeId,
        offset: {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        }
      };
    }

    handleMouseMove(e) {
      if (!this.dragState.isDragging || !this.dragState.nodeId) return;

      const canvasRect = this.canvas.getBoundingClientRect();
      let newPosition = {
        x: e.clientX - canvasRect.left - this.dragState.offset.x,
        y: e.clientY - canvasRect.top - this.dragState.offset.y
      };

      // Snap to grid (20px grid to match background)
      const gridSize = 20;
      newPosition.x = Math.round(newPosition.x / gridSize) * gridSize;
      newPosition.y = Math.round(newPosition.y / gridSize) * gridSize;

      // Constrain to canvas bounds
      newPosition.x = Math.max(10, Math.min(newPosition.x, canvasRect.width - 100));
      newPosition.y = Math.max(10, Math.min(newPosition.y, canvasRect.height - 50));

      const node = this.nodes.get(this.dragState.nodeId);
      if (node) {
        node.position = newPosition;
        const nodeEl = document.getElementById(node.id);
        
        // Disable transitions during drag for performance
        nodeEl.style.transition = 'none';
        nodeEl.style.left = `${newPosition.x}px`;
        nodeEl.style.top = `${newPosition.y}px`;
        
        this.updateConnections();
      }
    }

    handleMouseUp() {
      // Re-enable transitions after drag
      if (this.dragState.nodeId) {
        const nodeEl = document.getElementById(this.dragState.nodeId);
        if (nodeEl) {
          nodeEl.style.transition = '';
        }
      }
      this.dragState = { isDragging: false, nodeId: null, offset: { x: 0, y: 0 } };
    }

    handlePortClick(portId, nodeId, isOutput) {
      const portKey = `${nodeId}-${portId}`;

      
      if (this.connecting.from === null) {
        // Start connection from output port only
        if (isOutput) {
          this.connecting.from = portKey;
          this.showConnectionFeedback();


      } else if (this.connecting.from !== portKey) {
        // Complete connection to input port only
        if (!isOutput) {
          console.log('✅ Completing connection:', this.connecting.from, '→', portKey);
          this.addConnection(this.connecting.from, portKey);
          console.log('🔗 Connection added. Total connections:', this.connections.length);
        } else {
          console.log('❌ Cannot connect output to output');
        }
        this.connecting = { from: null, to: null };
        this.hideConnectionFeedback();
      } else {
        // Cancel connection (clicking same port)
        console.log('🚫 Canceling connection');
        this.connecting = { from: null, to: null };
        this.hideConnectionFeedback();
      }
    }

    showConnectionFeedback() {
      // Highlight available input ports with pulsing animation
      document.querySelectorAll('.input-port').forEach(port => {
        port.style.background = '#10b981';
        port.style.transform = 'scale(1.4)';
        port.style.animation = 'pulse 1s infinite';
        port.style.boxShadow = '0 0 10px rgba(16, 185, 129, 0.6)';
      });
      
      // Dim output ports
      document.querySelectorAll('.output-port').forEach(port => {
        port.style.opacity = '0.3';
      });
    }

    hideConnectionFeedback() {
      // Reset all port styles
      document.querySelectorAll('.port').forEach(port => {
        port.style.background = '';
        port.style.transform = '';
        port.style.animation = '';
        port.style.boxShadow = '';
        port.style.opacity = '';
      });
    }

    addConnection(from, to) {
      console.log('🔗 addConnection called:', { from, to });
      
      // Prevent self-connection
      // Connection format is "nodeId-portId", need to extract nodeId properly
      const fromNodeId = from.substring(0, from.lastIndexOf('-'));
      const toNodeId = to.substring(0, to.lastIndexOf('-'));
      if (fromNodeId === toNodeId) {
        console.log('❌ Cannot connect node to itself');
        return;
      }
      
      // Check if connection already exists
      const exists = this.connections.some(conn => conn.from === from && conn.to === to);
      if (exists) {
        console.log('❌ Connection already exists');
        return;
      }

      const connection = {
        id: this.generateId(),
        from,
        to
      };
      this.connections.push(connection);
      console.log('✅ Connection added:', connection);
      console.log('📊 Total connections:', this.connections.length);
      
      // If we're on the main canvas and have a backup, update it
      if (!this.isEditingComponent && this.mainCanvasBackup) {
        this.mainCanvasBackup.connections.push(connection);
      }
      
      this.updateConnections();
      this.updateEquation();
    }

    selectNode(nodeId) {
      this.selectedNode = nodeId;
      document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
      document.getElementById(nodeId).classList.add('selected');
      this.openSidebar(nodeId);
    }

    deselectAll() {
      this.selectedNode = null;
      document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
      this.closeSidebar();
    }

    openSidebar(nodeId) {
      const node = this.nodes.get(nodeId);
      if (!node) return;

      document.getElementById('sidebar-title').textContent = `Edit ${node.type}`;
      
      let content = '';
      if (node.type === 'number') {
        content = `
          <div class="input-group">
            <label>Value:</label>
            <input type="number" id="node-value" value="${node.value || 0}" step="0.1">
          </div>
        `;
      } else if (node.type === 'componentInput') {
        content = `
          <div class="input-group">
            <label>Test Value:</label>
            <input type="number" id="node-value" value="${node.value || 0}" step="0.1">
          </div>
          <div class="input-group">
            <label>Input Name:</label>
            <input type="text" id="node-label" value="${node.label || 'Input'}" maxlength="20">
          </div>
          <p style="font-size: 12px; color: #666; margin-top: 10px;">
            This input will receive data from the main equation when the component is used.
          </p>
        `;
      } else if (node.type === 'variable') {
        content = `
          <div class="input-group">
            <label>Variable name:</label>
            <input type="text" id="node-variable" value="${node.variable || 'x'}" maxlength="5">
          </div>
        `;
      } else if (node.type === 'conditional') {
        const currentInputs = node.inputs || ['value', 'condition', 'min', 'max'];
        const currentOutputs = node.outputs || ['true', 'false'];
        
        content = `
          <div class="input-group">
            <label>Condition Type:</label>
            <select id="condition-type">
              <option value="range" ${(node.conditionType || 'range') === 'range' ? 'selected' : ''}>Range (min ≤ x ≤ max)</option>
              <option value="greater" ${node.conditionType === 'greater' ? 'selected' : ''}>Greater than (x > min)</option>
              <option value="less" ${node.conditionType === 'less' ? 'selected' : ''}>Less than (x < max)</option>
              <option value="equal" ${node.conditionType === 'equal' ? 'selected' : ''}>Equal to (x = min)</option>
              <option value="custom" ${node.conditionType === 'custom' ? 'selected' : ''}>Custom conditions</option>
            </select>
          </div>
          
          <div class="input-group">
            <label>Input Ports:</label>
            <div style="display: flex; align-items: center; gap: 8px; margin-top: 4px;">
              <button id="remove-input" style="background: #ef4444; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">−</button>
              <span id="input-count">${currentInputs.length} inputs</span>
              <button id="add-input" style="background: #10b981; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">+</button>
            </div>
            <div id="input-list" style="margin-top: 8px;">
              ${currentInputs.map((input, i) => `
                <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 4px;">
                  <input type="text" value="${input}" data-input-index="${i}" style="flex: 1; padding: 4px; border: 1px solid #d1d5db; border-radius: 3px; font-size: 12px;">
                </div>
              `).join('')}
            </div>
          </div>
          
          <div class="input-group">
            <label>Output Ports:</label>
            <div style="display: flex; align-items: center; gap: 8px; margin-top: 4px;">
              <button id="remove-output" style="background: #ef4444; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">−</button>
              <span id="output-count">${currentOutputs.length} outputs</span>
              <button id="add-output" style="background: #10b981; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">+</button>
            </div>
            <div id="output-list" style="margin-top: 8px;">
              ${currentOutputs.map((output, i) => `
                <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 4px;">
                  <input type="text" value="${output}" data-output-index="${i}" style="flex: 1; padding: 4px; border: 1px solid #d1d5db; border-radius: 3px; font-size: 12px;">
                </div>
              `).join('')}
            </div>
          </div>
          
          <button id="update-conditional" style="background: #3b82f6; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; width: 100%; margin-top: 12px;">Update Node</button>
        `;
      } else if (node.type === 'component') {
        const currentInputs = node.inputs || [];
        const currentOutputs = node.outputs || [];
        
        content = `
          <div class="input-group">
            <label>Component Name:</label>
            <input type="text" id="component-name" value="${node.customName || node.label || 'Component'}" maxlength="20" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; margin-top: 4px;">
          </div>
          
          
          
          <button id="edit-component-logic" style="background: #9333ea; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; width: 100%; margin-top: 12px;">Edit Component Logic</button>
        `;
      }
      
      content += `
        <button class="delete-btn" id="delete-node-${nodeId}">Delete Node</button>
      `;
      
      document.getElementById('sidebar-content').innerHTML = content;
      
      // Add delete button event listener
      const deleteBtn = document.getElementById(`delete-node-${nodeId}`);
      if (deleteBtn) {
        deleteBtn.addEventListener('click', () => {
          this.deleteNode(nodeId);
        });
      }
      
      // Add event listeners for inputs
      const valueInput = document.getElementById('node-value');
      if (valueInput) {
        valueInput.addEventListener('input', (e) => {
          node.value = parseFloat(e.target.value) || 0;
          node.label = node.value.toString();
          document.querySelector(`#${nodeId} .node-content`).textContent = node.label;
          this.updateEquation();
        });
      }
      
      const variableInput = document.getElementById('node-variable');
      if (variableInput) {
        variableInput.addEventListener('input', (e) => {
          node.variable = e.target.value || 'x';
          node.label = node.variable;
          document.querySelector(`#${nodeId} .node-content`).textContent = node.label;
          this.updateEquation();
        });
      }

      const labelInput = document.getElementById('node-label');
      if (labelInput) {
        labelInput.addEventListener('input', (e) => {
          node.label = e.target.value || 'Input';
          document.querySelector(`#${nodeId} .node-content`).textContent = node.label;
          this.updateEquation();
        });
      }

      // Conditional node controls
      if (node.type === 'conditional') {
        // Add input button
        const addInputBtn = document.getElementById('add-input');
        if (addInputBtn) {
          addInputBtn.addEventListener('click', () => {
            const currentInputs = node.inputs || ['value', 'condition', 'min', 'max'];
            currentInputs.push(`input${currentInputs.length + 1}`);
            node.inputs = currentInputs;
            this.openSidebar(node); // Refresh sidebar
            this.rerenderNode(node);
          });
        }

        // Remove input button
        const removeInputBtn = document.getElementById('remove-input');
        if (removeInputBtn) {
          removeInputBtn.addEventListener('click', () => {
            const currentInputs = node.inputs || ['value', 'condition', 'min', 'max'];
            if (currentInputs.length > 2) { // Keep at least 2 inputs
              currentInputs.pop();
              node.inputs = currentInputs;
              this.openSidebar(node); // Refresh sidebar
              this.rerenderNode(node);
            }
          });
        }

        // Add output button
        const addOutputBtn = document.getElementById('add-output');
        if (addOutputBtn) {
          addOutputBtn.addEventListener('click', () => {
            const currentOutputs = node.outputs || ['true', 'false'];
            currentOutputs.push(`output${currentOutputs.length + 1}`);
            node.outputs = currentOutputs;
            this.openSidebar(node); // Refresh sidebar
            this.rerenderNode(node);
          });
        }

        // Remove output button
        const removeOutputBtn = document.getElementById('remove-output');
        if (removeOutputBtn) {
          removeOutputBtn.addEventListener('click', () => {
            const currentOutputs = node.outputs || ['true', 'false'];
            if (currentOutputs.length > 1) { // Keep at least 1 output
              currentOutputs.pop();
              node.outputs = currentOutputs;
              this.openSidebar(node); // Refresh sidebar
              this.rerenderNode(node);
            }
          });
        }

        // Update conditional button
        const updateConditionalBtn = document.getElementById('update-conditional');
        if (updateConditionalBtn) {
          updateConditionalBtn.addEventListener('click', () => {
            const conditionType = document.getElementById('condition-type').value;
            
            // Update input names from text inputs
            const inputElements = document.querySelectorAll('#input-list input');
            const newInputs = Array.from(inputElements).map(input => input.value.trim() || 'input');
            
            // Update output names from text inputs
            const outputElements = document.querySelectorAll('#output-list input');
            const newOutputs = Array.from(outputElements).map(output => output.value.trim() || 'output');
            
            node.conditionType = conditionType;
            node.inputs = newInputs;
            node.outputs = newOutputs;
            
            this.rerenderNode(node);
            this.updateEquation();
          });
        }
      }

      // Component node controls
      if (node.type === 'component') {

        // Edit component logic button
        const editLogicBtn = document.getElementById('edit-component-logic');
        if (editLogicBtn) {
          editLogicBtn.addEventListener('click', () => {
            this.openComponentEditor(node.id);
          });
        }

        // Component name can be updated when saving
      }
      
      this.sidebar.classList.add('open');
    }

    closeSidebar() {
      this.sidebar.classList.remove('open');
    }

    rerenderNode(node) {
      // Remove existing node element
      const existingNode = document.getElementById(node.id);
      if (existingNode) {
        existingNode.remove();
      }
      
      // Re-render the node with updated configuration
      this.renderNode(node);
      
      // Update connections if any
      this.updateConnections();
    }

    // Removed redundant helper methods - use updateConnections() and updateEquation() directly

    deleteNode(nodeId) {
      // Remove node element
      const nodeEl = document.getElementById(nodeId);
      if (nodeEl) nodeEl.remove();
      
      // Remove from nodes map
      this.nodes.delete(nodeId);
      
      // Remove connections
      this.connections = this.connections.filter(conn => 
        !conn.from.startsWith(nodeId) && !conn.to.startsWith(nodeId)
      );
      
      // Handle component I/O nodes - update parent component ports
      const deletedNode = this.nodes.get(nodeId);
      if (deletedNode && deletedNode.componentIO && this.isEditingComponent) {
        this.updateParentComponentPorts();
      }
      
      this.updateConnections();
      this.updateEquation();
      this.closeSidebar();
    }

    // Dynamic Component Port Management
    updateComponentPortsInBackup(componentId) {
      if (!this.mainCanvasBackup || !this.mainCanvasBackup.nodes) return;
      
      const componentNode = this.mainCanvasBackup.nodes.get(componentId);
      if (!componentNode || componentNode.type !== 'component') return;
      
      // Scan current component data for I/O nodes
      const componentData = window.componentData[componentId];
      if (!componentData || !componentData.nodes) return;
      
      const inputNodes = [];
      const outputNodes = [];
      
      // Find all componentInput and componentOutput nodes
      for (const [, node] of componentData.nodes) {
        if (node.type === 'componentInput') {
          inputNodes.push({
            id: node.id,
            label: node.label || `Input${inputNodes.length + 1}`
          });
        } else if (node.type === 'componentOutput') {
          outputNodes.push({
            id: node.id,
            label: node.label || `Output${outputNodes.length + 1}`
          });
        }
      }
      
      // Update the component node's ports in the backup with simplified names
      componentNode.inputs = inputNodes.map((input, index) => `in${index + 1}`);
      componentNode.outputs = outputNodes.map((output, index) => `out${index + 1}`);
      
      // Store the mapping between port names and I/O node IDs for calculations
      componentData.portMapping = {
        inputs: {},
        outputs: {}
      };
      
      inputNodes.forEach((input, index) => {
        componentData.portMapping.inputs[`in${index + 1}`] = input.id;
      });
      
      outputNodes.forEach((output, index) => {
        console.log(`🔌 Mapping port out${index + 1} to ComponentOutput node:`, output.id, 'with label:', output.label);
        componentData.portMapping.outputs[`out${index + 1}`] = output.id;
      });
      
      console.log(`🔌 Updated component ${componentId} ports:`, {
        inputs: componentNode.inputs,
        outputs: componentNode.outputs,
        portMapping: componentData.portMapping
      });
    }
    
    updateParentComponentPorts() {
      if (!this.isEditingComponent || !this.currentComponentId) return;
      
      // Get the parent component node from the main canvas backup
      const parentComponentNode = this.mainCanvasBackup?.nodes?.get(this.currentComponentId);
      if (!parentComponentNode || parentComponentNode.type !== 'component') return;
      
      // Scan component data for input and output nodes
      const componentData = window.componentData[this.currentComponentId];
      if (!componentData || !componentData.nodes) return;
      
      const inputNodes = [];
      const outputNodes = [];
      
      // Find all componentInput and componentOutput nodes
      for (const [, node] of componentData.nodes) {
        if (node.type === 'componentInput') {
          inputNodes.push({
            id: node.id,
            label: node.label || `Input${inputNodes.length + 1}`
          });
        } else if (node.type === 'componentOutput') {
          outputNodes.push({
            id: node.id,
            label: node.label || `Output${outputNodes.length + 1}`
          });
        }
      }
      
      // Update the parent component's inputs and outputs with simplified names
      parentComponentNode.inputs = inputNodes.map((input, index) => `in${index + 1}`);
      parentComponentNode.outputs = outputNodes.map((output, index) => `out${index + 1}`);
      
      // Store the mapping between port names and I/O node IDs
      componentData.portMapping = {
        inputs: {},
        outputs: {}
      };
      
      inputNodes.forEach((input, index) => {
        componentData.portMapping.inputs[`in${index + 1}`] = input.id;
      });
      
      outputNodes.forEach((output, index) => {
        componentData.portMapping.outputs[`out${index + 1}`] = output.id;
      });
      
      // Re-render the component node with new ports
      this.rerenderComponentNode(this.currentComponentId);
    }
    
    getMainCanvasNode(nodeId) {
      // When editing component, access the backed up main canvas nodes
      if (this.mainCanvasBackup && this.mainCanvasBackup.nodes) {
        return this.mainCanvasBackup.nodes.get(nodeId);
      }
      // If not in component editing mode, use current nodes
      return this.nodes.get(nodeId);
    }
    
    rerenderComponentNode(nodeId) {
      // Update the component in the main canvas backup and re-render it if we're editing components
      if (this.mainCanvasBackup && this.mainCanvasBackup.nodes.has(nodeId)) {
        const componentNode = this.mainCanvasBackup.nodes.get(nodeId);
        
        // Find the existing component element in the DOM and update it
        const existingElement = document.getElementById(nodeId);
        if (existingElement) {
          // Remove old element and create new one with updated ports
          existingElement.remove();
          this.renderNode(componentNode);
          console.log(`📝 Component ${nodeId} visually updated with new ports`);
        } else {
          console.log(`📝 Component ${nodeId} ports updated - will reflect when returning to main canvas`);
        }
      }
    }
    
    calculateComponentResult(componentNodeId, requestedPortId) {
      console.log('🧮 calculateComponentResult called:', { componentNodeId, requestedPortId });
      
      // Get component data and port mapping
      console.log('🔍 Available component data keys:', Object.keys(window.componentData || {}));
      console.log('🎯 Looking for component ID:', componentNodeId);
      
      // First try direct lookup
      let componentData = window.componentData[componentNodeId];
      let actualComponentId = componentNodeId;
      
      // If not found, search for any component node that might be connected to this calculation
      if (!componentData) {
        console.log('🔄 Direct lookup failed, searching for connected component...');
        
        // Find the actual component node by checking all available component data
        for (const [availableId, data] of Object.entries(window.componentData || {})) {
          const node = this.nodes.get(availableId);
          if (node && node.type === 'component') {
            console.log('🎯 Found component node:', availableId);
            componentData = data;
            actualComponentId = availableId;
            break;
          }
        }
      }
      
      console.log('📊 Component data:', componentData);
      
      if (!componentData || !componentData.portMapping) {
        console.log('❌ No component data or port mapping for:', actualComponentId);
        return '?';
      }
      
      console.log('🔌 Port mapping:', componentData.portMapping);
      
      // Map the requested port ID to the corresponding component output node
      let actualOutputPort = requestedPortId;
      let outputNodeId = componentData.portMapping.outputs[requestedPortId];
      
      if (!outputNodeId) {
        console.log('🔄 Port ID translation needed - searching for connected output port...');
        
        // If the requestedPortId doesn't directly map, try to find it by matching connection
        // This handles cases where the external connection format differs from internal port names
        const outputPorts = Object.keys(componentData.portMapping.outputs);
        console.log('🎯 Available output ports:', outputPorts);
        
        // For single output, use it
        if (outputPorts.length === 1) {
          actualOutputPort = outputPorts[0];
          outputNodeId = componentData.portMapping.outputs[actualOutputPort];
          console.log('✅ Using single output port:', actualOutputPort, '→', outputNodeId);
        } else {
          // For multiple outputs, try to match the requested port ID format
          // Look for exact match first, then fall back to first available
          const matchingPort = outputPorts.find(port => 
            requestedPortId.includes(port) || port.includes(requestedPortId)
          );
          
          if (matchingPort) {
            actualOutputPort = matchingPort;
            outputNodeId = componentData.portMapping.outputs[actualOutputPort];
            console.log('✅ Found matching output port:', actualOutputPort, '→', outputNodeId);
          } else {
            actualOutputPort = outputPorts[0];
            outputNodeId = componentData.portMapping.outputs[actualOutputPort];
            console.log('⚠️ No exact match, using first output port:', actualOutputPort, '→', outputNodeId);
          }
        }
      } else {
        console.log('✅ Direct port mapping found:', actualOutputPort, '→', outputNodeId);
        console.log('🔍 Port mapping details:', componentData.portMapping.outputs);
      }
      
      console.log('🎯 Final output node ID for port', actualOutputPort, ':', outputNodeId);
      
      if (!outputNodeId) {
        console.log('❌ No output node found for port:', actualOutputPort);
        return '?';
      }
      
      // Set up input values from connections to the component (use actual component ID)
      this.setupComponentInputs(actualComponentId, componentData);
      
      // Calculate the result from the componentOutput node in the component's context
      const result = this.calculateComponentNodeResult(outputNodeId, componentData, actualComponentId);
      console.log('✅ Component calculation result:', result);
      return result;
    }
    
    setupComponentInputs(componentNodeId, componentData) {
      console.log('🔧 setupComponentInputs called for:', componentNodeId);
      console.log('🔧 Available main canvas connections:', this.connections.length);
      
      // Find all connections to this component's input ports
      const componentInputs = componentData.portMapping.inputs;
      console.log('🔧 Component input ports:', componentInputs);
      
      for (const [portName, inputNodeId] of Object.entries(componentInputs)) {
        console.log(`🔧 Processing input port ${portName} → ${inputNodeId}`);
        
        // Find connection to this input port
        const targetConnection = `${componentNodeId}-${portName}`;
        console.log('🔧 Looking for connection to:', targetConnection);
        
        const connection = this.connections.find(conn => 
          conn.to === targetConnection
        );
        
        console.log('🔧 Found connection:', connection);
        
        if (connection) {
          // Extract source info and calculate input value
          // Parse connection format: "node-ID-timestamp-port"
          const connectionParts = connection.from.split('-');
          const sourcePortId = connectionParts[connectionParts.length - 1]; // Last part is port
          const sourceNodeId = connectionParts.slice(0, -1).join('-'); // Everything before last part is node ID
          console.log('🔧 Parsed connection:', { sourceNodeId, sourcePortId });
          
          // Get the external source node directly (don't use calculateResult for external nodes)
          const externalSourceNode = this.getMainCanvasNode(sourceNodeId);
          console.log('🔧 External source node:', externalSourceNode);
          console.log('🔧 MainCanvasBackup exists:', !!this.mainCanvasBackup);
          if (this.mainCanvasBackup && this.mainCanvasBackup.nodes) {
            console.log('🔧 Available backup node IDs:', Array.from(this.mainCanvasBackup.nodes.keys()));
          }
          console.log('🔧 Looking for node ID:', sourceNodeId);
          
          let inputValue = '?';
          if (externalSourceNode) {
            switch (externalSourceNode.type) {
              case 'number':
                inputValue = parseFloat(externalSourceNode.value) || 0;
                break;
              case 'variable':
                inputValue = 2; // Demo value
                break;
              case 'component':
                inputValue = this.calculateComponentResult(sourceNodeId, sourcePortId);
                break;
              default:
                inputValue = this.calculateResult(sourceNodeId, sourcePortId);
            }
          }
          
          console.log('🔧 Calculated input value:', inputValue);
          
          // Set the input value on the componentInput node
          const inputNode = componentData.nodes.get(inputNodeId);
          if (inputNode) {
            inputNode.value = inputValue;
            console.log('🔧 Set input node value:', inputNode.value);
          } else {
            console.log('🔧 ❌ Input node not found:', inputNodeId);
          }
        } else {
          console.log('🔧 ❌ No connection found for port:', portName);
        }
      }
    }
    
    calculateComponentNodeResult(nodeId, componentData, actualComponentId) {
      console.log('🎯 calculateComponentNodeResult called for:', nodeId);
      
      // Use the component's internal nodes and connections for calculation
      const node = componentData.nodes.get(nodeId);
      console.log('📦 Node found:', node);
      
      if (!node) {
        console.log('❌ Node not found in component data');
        return '?';
      }
      
      // For componentOutput nodes, get the connected input value
      if (node.type === 'componentOutput') {
        console.log('🔍 Processing componentOutput node');
        
        // BULLETPROOF APPROACH: For simple components with one input and one output,
        // directly use the input value without relying on connection lookup
        const inputNodes = Array.from(componentData.nodes.values()).filter(n => n.type === 'componentInput');
        const outputNodes = Array.from(componentData.nodes.values()).filter(n => n.type === 'componentOutput');
        
        console.log('🔍 Component structure:', { 
          inputs: inputNodes.length, 
          outputs: outputNodes.length,
          totalNodes: componentData.nodes.size 
        });
        
        console.log('🔍 Checking simple pass-through condition:', { inputCount: inputNodes.length, outputCount: outputNodes.length });
        
        if (inputNodes.length === 1 && outputNodes.length === 1) {
          // Enhanced component calculation: get external input and process through internal logic
          console.log('🧮 Processing component with internal calculation');
          const inputNode = inputNodes[0];
          const outputNode = outputNodes[0];
          
          // Get the external input value
          const inputPortName = Object.keys(componentData.portMapping.inputs)[0]; // Should be 'in1'
          const targetPortId = `${actualComponentId}-${inputPortName}`;
          
          const connections = this.connections || [];
          const externalConnection = connections.find(conn => conn.to === targetPortId);
          
          let externalInputValue = 0; // Default value
          if (externalConnection) {
            const connectionParts = externalConnection.from.split('-');
            const sourcePortId = connectionParts.pop();
            const sourceNodeId = connectionParts.join('-');
            const mainNodes = this.nodes || new Map();
            const mainConnections = this.connections || [];
            const calculatedValue = this.calculateMainCanvasResult(sourceNodeId, sourcePortId, mainNodes, mainConnections);
            if (calculatedValue !== '?') {
              externalInputValue = calculatedValue;
            }
          }
          
          console.log('🔢 External input value:', externalInputValue);
          
          // Set the input value on the componentInput node
          inputNode.value = externalInputValue;
          
          // Now calculate through the component's internal structure to the output
          console.log('🔗 Calculating through internal component structure...');
          const internalResult = this.calculateComponentInternalResult(outputNode.id, 'in', componentData);
          console.log('✅ Internal calculation result:', internalResult);
          
          return internalResult !== '?' ? internalResult : externalInputValue;
        }
        
        // If not a simple case, try connection-based calculation
        const targetConnectionId = `${nodeId}-in`;
        console.log('🔗 Looking for connection to:', targetConnectionId);
        console.log('📋 Available connections:', componentData.connections);
        
        const connection = componentData.connections.find(conn =>
          conn.to === targetConnectionId
        );
        console.log('🎯 Found connection:', connection);
        
        if (connection) {
          // Parse connection format: "node-ID-timestamp-port"
          const connectionParts = connection.from.split('-');
          const portId = connectionParts[connectionParts.length - 1]; // Last part is port
          const sourceNodeId = connectionParts.slice(0, -1).join('-'); // Everything before last part is node ID
          console.log('⚡ Calculating from source:', { sourceNodeId, portId });
          
          // Recursively calculate using component's internal nodes
          const result = this.calculateComponentInternalResult(sourceNodeId, portId, componentData);
          console.log('✅ Internal calculation result:', result);
          return result;
        } else {
          console.log('❌ No connection found, trying fallback approach');
          
          // FALLBACK: If there's a componentInput, use its value
          if (inputNodes.length > 0) {
            const fallbackValue = inputNodes[0].value || 0;
            console.log('🔄 Using fallback input value:', fallbackValue);
            return fallbackValue;
          }
        }
      }
      
      console.log('❌ Node type not handled or no connection found');
      return '?';
    }
    
    calculateMainCanvasResult(nodeId, portId, nodes, connections) {
      const node = nodes.get(nodeId);
      if (!node) return '?';
      
      switch (node.type) {
        case 'number':
          return node.value || 0;
          
        case 'add': {
          const left = this.getMainCanvasInput(nodeId, 'in1', nodes, connections);
          const right = this.getMainCanvasInput(nodeId, 'in2', nodes, connections);
          if (left === '?' || right === '?') return '?';
          return left + right;
        }
        
        case 'subtract': {
          const left = this.getMainCanvasInput(nodeId, 'in1', nodes, connections);
          const right = this.getMainCanvasInput(nodeId, 'in2', nodes, connections);
          if (left === '?' || right === '?') return '?';
          return left - right;
        }
        
        case 'multiply': {
          const left = this.getMainCanvasInput(nodeId, 'in1', nodes, connections);
          const right = this.getMainCanvasInput(nodeId, 'in2', nodes, connections);
          if (left === '?' || right === '?') return '?';
          return left * right;
        }
        
        case 'divide': {
          const left = this.getMainCanvasInput(nodeId, 'in1', nodes, connections);
          const right = this.getMainCanvasInput(nodeId, 'in2', nodes, connections);
          if (left === '?' || right === '?' || right === 0) return '?';
          return left / right;
        }
        
        default:
          return node.value || 0;
      }
    }
    
    getMainCanvasInput(nodeId, portId, nodes, connections) {
      const targetConnectionId = `${nodeId}-${portId}`;
      const connection = connections.find(conn => conn.to === targetConnectionId);
      
      if (connection) {
        // Parse connection.from which is like "node-2-1760587322032-out"
        const fromParts = connection.from.split('-');
        const sourcePortId = fromParts.pop(); // "out"
        const sourceNodeId = fromParts.join('-'); // "node-2-1760587322032"
        return this.calculateMainCanvasResult(sourceNodeId, sourcePortId, nodes, connections);
      }
      
      return '?';
    }
    
    calculateComponentInternalResult(nodeId, portId, componentData) {
      const node = componentData.nodes.get(nodeId);
      if (!node) return '?';
      
      // Debug: calculateComponentInternalResult for node
      
      // Handle different node types within the component
      switch (node.type) {
        case 'componentInput':
          // Return the value that was set externally 
          console.log('📥 ComponentInput returning:', node.value);
          return node.value || 0;
          
        case 'componentOutput': {
          // For componentOutput, get the value from its input connection
          console.log('📤 ComponentOutput - looking for input connection');
          const inputValue = this.getComponentNodeInput(nodeId, 'in', componentData);
          console.log('📤 ComponentOutput input value:', inputValue);
          return inputValue;
        }
          
        case 'number':
          console.log('🔢 Number node value:', node.value, 'from node:', node.id);
          return node.value || 0;
          
        case 'add': {
          console.log('➕ Add operation');
          const left = this.getComponentNodeInput(nodeId, 'in1', componentData);
          const right = this.getComponentNodeInput(nodeId, 'in2', componentData);
          console.log('➕ Add inputs:', left, '+', right);
          if (left === '?' || right === '?') return '?';
          const result = left + right;
          console.log('➕ Add result:', result);
          return result;
        }
        
        case 'subtract': {
          console.log('➖ Subtract operation');
          const left = this.getComponentNodeInput(nodeId, 'in1', componentData);
          const right = this.getComponentNodeInput(nodeId, 'in2', componentData);
          console.log('➖ Subtract inputs:', left, '-', right);
          if (left === '?' || right === '?') return '?';
          const result = left - right;
          console.log('➖ Subtract result:', result);
          return result;
        }
        
        case 'multiply': {
          console.log('✖️ Multiply operation');
          const left = this.getComponentNodeInput(nodeId, 'in1', componentData);
          const right = this.getComponentNodeInput(nodeId, 'in2', componentData);
          console.log('✖️ Multiply inputs:', left, '×', right);
          if (left === '?' || right === '?') return '?';
          const result = left * right;
          console.log('✖️ Multiply result:', result);
          return result;
        }
        
        case 'divide': {
          console.log('➗ Divide operation');
          const left = this.getComponentNodeInput(nodeId, 'in1', componentData);
          const right = this.getComponentNodeInput(nodeId, 'in2', componentData);
          console.log('➗ Divide inputs:', left, '÷', right);
          if (left === '?' || right === '?' || right === 0) return '?';
          const result = left / right;
          console.log('➗ Divide result:', result);
          return result;
        }
        
        case 'power': {
          console.log('🔺 Power operation');
          const base = this.getComponentNodeInput(nodeId, 'base', componentData);
          const exp = this.getComponentNodeInput(nodeId, 'exp', componentData);
          console.log('🔺 Power inputs:', base, '^', exp);
          if (base === '?' || exp === '?') return '?';
          const result = Math.pow(base, exp);
          console.log('🔺 Power result:', result);
          return result;
        }
        
        // Advanced math operations
        case 'sqrt': {
          const value = this.getComponentNodeInput(nodeId, 'value', componentData);
          const root = this.getComponentNodeInput(nodeId, 'root', componentData);
          const rootValue = (root === '?' || root === null) ? 2 : root;
          if (value === '?' || value < 0) return '?';
          return Math.pow(value, 1 / rootValue);
        }
        
        case 'sin': {
          const input = this.getComponentNodeInput(nodeId, 'in', componentData);
          if (input === '?') return '?';
          return Math.sin(input);
        }
        
        case 'cos': {
          const input = this.getComponentNodeInput(nodeId, 'in', componentData);
          if (input === '?') return '?';
          return Math.cos(input);
        }
        
        case 'tan': {
          const input = this.getComponentNodeInput(nodeId, 'in', componentData);
          if (input === '?') return '?';
          return Math.tan(input);
        }
        
        default:
          console.log('❓ Unknown node type in component:', node.type);
          return node.value || '?';
      }
    }
    
    getComponentNodeInput(nodeId, portId, componentData) {
      const targetConnectionId = `${nodeId}-${portId}`;
      const connection = componentData.connections.find(conn =>
        conn.to === targetConnectionId
      );
      
      if (connection) {
        // Parse connection.from which is like "node-2-1760587322032-out"
        const fromParts = connection.from.split('-');
        const sourcePortId = fromParts.pop(); // "out"
        const sourceNodeId = fromParts.join('-'); // "node-2-1760587322032"
        
        console.log('🔗 getComponentNodeInput found connection:', {
          target: targetConnectionId,
          source: sourceNodeId,
          sourcePort: sourcePortId
        });
        
        return this.calculateComponentInternalResult(sourceNodeId, sourcePortId, componentData);
      }
      
      console.log('❌ No connection found for:', targetConnectionId);
      return '?';
    }
    
    buildComponentEquation(componentNodeId, requestedPortId) {
      // Get component data and port mapping
      const componentData = window.componentData[componentNodeId];
      if (!componentData || !componentData.portMapping) {
        return 'Component()';
      }
      
      // Find which componentOutput node corresponds to the requested port
      const outputNodeId = componentData.portMapping.outputs[requestedPortId];
      if (!outputNodeId) {
        return 'Component()';
      }
      
      // Build equation from the componentOutput node in the component's context
      return this.buildComponentInternalEquation(outputNodeId, componentData) || 'Component()';
    }
    
    buildComponentInternalEquation(nodeId, componentData) {
      const node = componentData.nodes.get(nodeId);
      if (!node) return 'Component()';
      
      // For componentOutput nodes, get the connected input equation
      if (node.type === 'componentOutput') {
        const connection = componentData.connections.find(conn =>
          conn.to === `${nodeId}-in`
        );
        
        if (connection) {
          // Parse connection format: "node-ID-timestamp-port"
          const connectionParts = connection.from.split('-');
          const sourceNodeId = connectionParts.slice(0, -1).join('-'); // Everything before last part is node ID
          return this.buildComponentInternalEquation(sourceNodeId, componentData);
        }
      }
      
      // Handle different node types within the component
      switch (node.type) {
        case 'componentInput':
          return node.label || 'Input';
          
        case 'number':
          return node.value?.toString() || '0';
          
        case 'add': {
          const left = this.getComponentNodeEquation(nodeId, 'in1', componentData);
          const right = this.getComponentNodeEquation(nodeId, 'in2', componentData);
          if (!left || !right) return '';
          return `(${left} + ${right})`;
        }
        
        case 'multiply': {
          const left = this.getComponentNodeEquation(nodeId, 'in1', componentData);
          const right = this.getComponentNodeEquation(nodeId, 'in2', componentData);
          if (!left || !right) return '';
          return `(${left} × ${right})`;
        }
        
        default:
          return node.label || node.type;
      }
    }
    
    getComponentNodeEquation(nodeId, portId, componentData) {
      const connection = componentData.connections.find(conn =>
        conn.to === `${nodeId}-${portId}`
      );
      
      if (connection) {
        // Parse connection format: "node-ID-timestamp-port"
        const connectionParts = connection.from.split('-');
        const sourceNodeId = connectionParts.slice(0, -1).join('-'); // Everything before last part is node ID
        return this.buildComponentInternalEquation(sourceNodeId, componentData);
      }
      
      return '';
    }

    updateConnections() {
      this.connectionsSvg.innerHTML = '';
      
      if (this.connections.length === 0) {
        return;
      }
      
      this.connections.forEach((conn, index) => {
        // Parse connection IDs properly (e.g., "node-1-1734454973667-out" -> nodeId="node-1-1734454973667", portId="out")
        const fromParts = conn.from.split('-');
        const fromPortId = fromParts.pop();
        const fromNodeId = fromParts.join('-');
        
        const toParts = conn.to.split('-');
        const toPortId = toParts.pop();
        const toNodeId = toParts.join('-');
        
        const fromEl = document.querySelector(`#${fromNodeId} [data-port="${fromPortId}"]`);
        const toEl = document.querySelector(`#${toNodeId} [data-port="${toPortId}"]`);
        
        if (fromEl && toEl) {
          const fromRect = fromEl.getBoundingClientRect();
          const toRect = toEl.getBoundingClientRect();
          const canvasRect = this.canvas.getBoundingClientRect();
          
          // Calculate port positions relative to canvas
          const fromPos = {
            x: fromRect.left - canvasRect.left + fromRect.width / 2,
            y: fromRect.top - canvasRect.top + fromRect.height / 2
          };
          
          const toPos = {
            x: toRect.left - canvasRect.left + toRect.width / 2,
            y: toRect.top - canvasRect.top + toRect.height / 2
          };
          
          // Create beautiful S-shaped curve using cubic bezier
          const dx = toPos.x - fromPos.x;
          const controlOffset = Math.abs(dx) * 0.5 + 50; // Dynamic curve based on distance
          
          const control1 = {
            x: fromPos.x + controlOffset,
            y: fromPos.y
          };
          
          const control2 = {
            x: toPos.x - controlOffset,
            y: toPos.y
          };
          
          // Create SVG group for connection (path + arrowhead)
          const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          group.classList.add('connection-group');
          group.style.pointerEvents = 'auto';
          group.style.opacity = '1';
          group.style.visibility = 'visible';
          group.style.zIndex = '10';
          
          // Main connection path (S-curve)
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          const d = `M ${fromPos.x} ${fromPos.y} C ${control1.x} ${control1.y} ${control2.x} ${control2.y} ${toPos.x} ${toPos.y}`;
          
          path.setAttribute('d', d);
          path.setAttribute('stroke', '#3b82f6');
          path.setAttribute('stroke-width', '3');
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke-linecap', 'round');
          path.setAttribute('opacity', '1');
          path.style.cursor = 'pointer';
          path.style.visibility = 'visible';
          path.style.display = 'block';
          path.style.filter = 'drop-shadow(0 2px 4px rgba(0,0,0,0.1))';
          
          // Arrowhead marker
          const arrowhead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
          const arrowSize = 8;
          const angle = Math.atan2(toPos.y - control2.y, toPos.x - control2.x);
          
          const arrowPoints = [
            { x: toPos.x, y: toPos.y },
            { 
              x: toPos.x - arrowSize * Math.cos(angle - Math.PI / 6), 
              y: toPos.y - arrowSize * Math.sin(angle - Math.PI / 6) 
            },
            { 
              x: toPos.x - arrowSize * Math.cos(angle + Math.PI / 6), 
              y: toPos.y - arrowSize * Math.sin(angle + Math.PI / 6) 
            }
          ];
          
          arrowhead.setAttribute('points', arrowPoints.map(p => `${p.x},${p.y}`).join(' '));
          arrowhead.setAttribute('fill', '#3b82f6');
          arrowhead.setAttribute('opacity', '1');
          arrowhead.style.visibility = 'visible';
          arrowhead.style.display = 'block';
          arrowhead.style.filter = 'drop-shadow(0 1px 2px rgba(0,0,0,0.1))';
          
          // Add hover effects
          group.addEventListener('mouseenter', () => {
            path.setAttribute('stroke', '#1d4ed8');
            path.setAttribute('stroke-width', '4');
            arrowhead.setAttribute('fill', '#1d4ed8');
          });
          
          group.addEventListener('mouseleave', () => {
            path.setAttribute('stroke', '#3b82f6');
            path.setAttribute('stroke-width', '3');
            arrowhead.setAttribute('fill', '#3b82f6');
          });
          
          // Add click to delete connection
          group.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm('Delete this connection?')) {
              this.connections = this.connections.filter(c => c.id !== conn.id);
              this.updateConnections();
              this.updateEquation();
            }
          });
          
          group.appendChild(path);
          group.appendChild(arrowhead);
          this.connectionsSvg.appendChild(group);
          
          // SVG connection rendered successfully
          
        } else {
          console.warn('Could not find elements for connection:', conn.from, '→', conn.to);
        }
      });
    }

    updateEquation() {
      // Find ALL output/display nodes, not just the first one
      const outputNodes = Array.from(this.nodes.values()).filter(node => node.type === 'output');
      if (outputNodes.length === 0) {
        this.equationDisplay.textContent = 'Add an Output node to see the equation...';
        this.equationDisplay.style.color = '#9ca3af';
        return;
      }

      // Update each output node individually
      outputNodes.forEach(outputNode => {
        const equation = this.buildEquation(outputNode.id, 'in');
        const result = this.calculateResult(outputNode.id, 'in');
        
        // Update the Result node itself to show the computed value
        const outputNodeEl = document.getElementById(outputNode.id);
        if (outputNodeEl) {
          const contentEl = outputNodeEl.querySelector('.node-content');
          if (contentEl) {
            if (equation) {
              contentEl.textContent = `Result: ${result}`;
            } else {
              contentEl.textContent = 'Output';
            }
          }
        }
      });

      // Update the main equation display with the first output node (for backward compatibility)
      const firstOutputNode = outputNodes[0];
      const equation = this.buildEquation(firstOutputNode.id, 'in');
      const result = this.calculateResult(firstOutputNode.id, 'in');
      
      if (equation) {
        // Update equation display
        this.equationDisplay.textContent = `${equation} = ${result}`;
        this.equationDisplay.style.color = '#1e293b';
      } else {
        this.equationDisplay.textContent = 'Connect nodes to the Output to generate equation...';
        this.equationDisplay.style.color = '#9ca3af';
      }

      // Legacy code for resetting display - moved into forEach above
      if (!equation) {
        const outputNodeEl = document.getElementById(firstOutputNode.id);
        if (outputNodeEl) {
          const contentEl = outputNodeEl.querySelector('.node-content');
          if (contentEl) {
            contentEl.textContent = 'Result';
          }
        }
      }
    }
    
    calculateResult(nodeId, portId) {
      console.log('🔍 calculateResult called:', { nodeId, portId });
      const connection = this.connections.find(conn => conn.to === `${nodeId}-${portId}`);
      console.log('🔍 Found connection:', connection);
      if (!connection) {
        console.log('🔍 No connection found, returning ?');
        return '?';
      }

      const parts = connection.from.split('-');
      parts.pop(); // Remove port id
      const sourceNodeId = parts.join('-');
      console.log('🔍 Looking for source node:', sourceNodeId);
      const sourceNode = this.getMainCanvasNode(sourceNodeId);
      console.log('🔍 Found source node:', sourceNode);
      if (!sourceNode) {
        console.log('🔍 Source node not found, returning ?');
        return '?';
      }

      switch (sourceNode.type) {
        // Generators
        case 'number':
          return parseFloat(sourceNode.value) || 0;
        case 'variable':
          return 2; // Demo: x = 2
        case 'constant_pi':
          return Math.PI;
        case 'constant_e':
          return Math.E;
          
        // Basic Operators
        case 'add': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left + right;
        }
        case 'subtract': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left - right;
        }
        case 'multiply': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left * right;
        }
        case 'divide': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?' || right === 0) return '?';
          return left / right;
        }
        case 'power': {
          const base = this.calculateResult(sourceNode.id, 'base');
          const exp = this.calculateResult(sourceNode.id, 'exp');
          if (base === '?' || exp === '?') return '?';
          return Math.pow(base, exp);
        }
        case 'modulo': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?' || right === 0) return '?';
          return left % right;
        }
        
        // Advanced Math
        case 'sqrt': {
          const value = this.calculateResult(sourceNode.id, 'value');
          const root = this.calculateResult(sourceNode.id, 'root');
          
          // Default to square root if no root specified
          const rootValue = (root === '?' || root === null || root === undefined) ? 2 : root;
          
          if (value === '?' || value < 0 || rootValue === 0) return '?';
          return Math.pow(value, 1 / rootValue);
        }
        case 'log': {
          const value = this.calculateResult(sourceNode.id, 'value');
          const base = this.calculateResult(sourceNode.id, 'base');
          
          // Default to log base 10 if no base specified
          const baseValue = (base === '?' || base === null || base === undefined) ? 10 : base;
          
          if (value === '?' || value <= 0 || baseValue === '?' || baseValue <= 0 || baseValue === 1) return '?';
          return Math.log(value) / Math.log(baseValue);
        }
        case 'ln': {
          const input = this.calculateResult(sourceNode.id, 'in');
          if (input === '?' || input <= 0) return '?';
          return Math.log(input);
        }
        case 'abs': {
          const input = this.calculateResult(sourceNode.id, 'in');
          if (input === '?') return '?';
          return Math.abs(input);
        }
        
        // Trigonometry
        case 'sin': {
          const input = this.calculateResult(sourceNode.id, 'in');
          if (input === '?') return '?';
          return Math.sin(input);
        }
        case 'cos': {
          const input = this.calculateResult(sourceNode.id, 'in');
          if (input === '?') return '?';
          return Math.cos(input);
        }
        case 'tan': {
          const input = this.calculateResult(sourceNode.id, 'in');
          if (input === '?') return '?';
          return Math.tan(input);
        }
        
        // Comparison
        case 'equals': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left === right ? 1 : 0;
        }
        case 'greater': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left > right ? 1 : 0;
        }
        case 'less': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left < right ? 1 : 0;
        }
        
        // Advanced Components
        case 'component': {
          console.log('🎯 Component case triggered for:', nodeId, portId);
          // Extract the component output port from the connection
          const componentOutputPort = connection.from.split('-').pop();
          console.log('🔍 Component output port:', componentOutputPort);
          return this.calculateComponentResult(sourceNode.id, componentOutputPort);
        }
        case 'conditional': {
          const value = this.calculateResult(sourceNode.id, 'value');
          const condition = this.calculateResult(sourceNode.id, 'condition') || 'range'; // Default to range check
          const min = this.calculateResult(sourceNode.id, 'min') || 0;
          const max = this.calculateResult(sourceNode.id, 'max') || 100;
          
          if (value === '?') return '?';
          
          // Check condition based on type
          let conditionMet = false;
          if (condition === 'range' || condition === 'between') {
            conditionMet = (value >= min && value <= max);
          } else if (condition === 'greater') {
            conditionMet = (value > min);
          } else if (condition === 'less') {
            conditionMet = (value < max);
          } else if (condition === 'equal') {
            conditionMet = (value === min);
          }
          
          // For calculation purposes, return 1 if condition met, 0 if not
          return conditionMet ? 1 : 0;
        }

        // Component I/O nodes
        case 'componentInput': {
          // Component input nodes get their values from the main equation context
          // For now, return a placeholder value (needs proper integration)
          return sourceNode.value || 0;
        }
        case 'componentOutput': {
          // Component output nodes pass through their input value
          const input = this.calculateResult(sourceNode.id, 'in');
          return input !== '?' ? input : 0;
        }
        
        default:
          return '?';
      }
    }

    buildEquation(nodeId, portId) {
      console.log('🔍 buildEquation called:', nodeId, portId);
      
      const connection = this.connections.find(conn => conn.to === `${nodeId}-${portId}`);
      if (!connection) {
        console.log('❌ No connection found to:', `${nodeId}-${portId}`);
        return '';
      }
      
      console.log('🔗 Found connection:', connection);

      // Parse source node ID properly (e.g., "node-1-1234567-out" -> "node-1-1234567")
      const fromParts = connection.from.split('-');
      fromParts.pop(); // Remove port id
      const sourceNodeId = fromParts.join('-');
      
      console.log('📍 Source node ID:', sourceNodeId);
      
      const sourceNode = this.nodes.get(sourceNodeId);
      if (!sourceNode) {
        console.log('❌ Source node not found:', sourceNodeId);
        return '';
      }
      
      console.log('✅ Source node found:', sourceNode);

      switch (sourceNode.type) {
        // Generators
        case 'number':
          return sourceNode.value?.toString() || '0';
        case 'variable':
          return sourceNode.variable || 'x';
        case 'constant_pi':
          return 'π';
        case 'constant_e':
          return 'e';
          
        // Binary Operators
        case 'add':
        case 'subtract':
        case 'multiply':
        case 'divide':
        case 'modulo':
        case 'equals':
        case 'greater':
        case 'less': {
          const left = this.buildEquation(sourceNode.id, 'in1');
          const right = this.buildEquation(sourceNode.id, 'in2');
          if (!left || !right) return '';
          
          const operators = { 
            add: '+', subtract: '-', multiply: '*', divide: '/', modulo: '%',
            equals: '=', greater: '>', less: '<'
          };
          const op = operators[sourceNode.type];
          return `(${left} ${op} ${right})`;
        }
        
        case 'power': {
          const base = this.buildEquation(sourceNode.id, 'base');
          const exp = this.buildEquation(sourceNode.id, 'exp');
          if (!base || !exp) return '';
          return `(${base}^${exp})`;
        }
        
        // Unary Operators
        case 'sqrt': {
          const value = this.buildEquation(sourceNode.id, 'value');
          const root = this.buildEquation(sourceNode.id, 'root');
          
          if (!value) return '';
          
          // If root is specified and not default 2, show nth root notation
          if (root && root !== '2') {
            return `${root}√(${value})`;
          } else {
            return `√(${value})`;
          }
        }
        case 'log': {
          const value = this.buildEquation(sourceNode.id, 'value');
          const base = this.buildEquation(sourceNode.id, 'base');
          
          if (!value) return '';
          
          // If base is specified and not default 10, show subscript base
          if (base && base !== '10') {
            return `log_${base}(${value})`;
          } else {
            return `log(${value})`;
          }
        }
        case 'ln': {
          const input = this.buildEquation(sourceNode.id, 'in');
          if (!input) return '';
          return `ln(${input})`;
        }
        case 'abs': {
          const input = this.buildEquation(sourceNode.id, 'in');
          if (!input) return '';
          return `|${input}|`;
        }
        case 'sin': {
          const input = this.buildEquation(sourceNode.id, 'in');
          if (!input) return '';
          return `sin(${input})`;
        }
        case 'cos': {
          const input = this.buildEquation(sourceNode.id, 'in');
          if (!input) return '';
          return `cos(${input})`;
        }
        case 'tan': {
          const input = this.buildEquation(sourceNode.id, 'in');
          if (!input) return '';
          return `tan(${input})`;
        }
        
        // Advanced Components
        case 'component': {
          // Get the port ID from the connection
          const sourcePortId = connection.from.split('-').pop();
          return this.buildComponentEquation(sourceNodeId, sourcePortId);
        }
        case 'conditional': {
          const value = this.buildEquation(sourceNode.id, 'value');
          const condition = this.buildEquation(sourceNode.id, 'condition');
          const min = this.buildEquation(sourceNode.id, 'min');
          const max = this.buildEquation(sourceNode.id, 'max');
          
          if (!value) return '';
          
          if (min && max) {
            return `IF(${value} ∈ [${min}, ${max}])`;
          } else if (condition === 'greater' && min) {
            return `IF(${value} > ${min})`;
          } else if (condition === 'less' && max) {
            return `IF(${value} < ${max})`;
          } else {
            return `IF(${value})`;
          }
        }

        // Component I/O nodes
        case 'componentInput': {
          return sourceNode.label || 'Input';
        }
        case 'componentOutput': {
          const input = this.buildEquation(sourceNode.id, 'in');
          return input || 'Output';
        }
        
        default:
          return '';
      }
    }
  }

  // Initialize when DOM is ready
  let equationBuilder;
  document.addEventListener('DOMContentLoaded', () => {
    equationBuilder = new CleanEquationBuilder();
    
    // Handle window resize
    window.addEventListener('resize', () => {
      setTimeout(() => {
        equationBuilder.updateConnections();
      }, 100);
    });
  });
</script>

<style>
  .section {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem 1rem;
    text-align: center;
  }

  .section h2 {
    font-size: 2.5rem;
    color: #1e293b;
    margin-bottom: 1rem;
  }

  .section p {
    font-size: 1.1rem;
    color: #64748b;
    margin-bottom: 2rem;
  }

  .equation-builder {
    display: flex;
    height: 600px;
    max-width: 1200px;
    margin: 0 auto;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    background: #f8fafc;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  }

  .node-palette {
    width: 200px;
    background: white;
    border-right: 1px solid #e2e8f0;
    padding: 16px;
    overflow-y: auto;
  }

  .node-palette h3 {
    font-size: 16px;
    font-weight: 600;
    color: #1e293b;
    margin-bottom: 16px;
  }

  .palette-section {
    margin-bottom: 20px;
  }

  .palette-section h4 {
    font-size: 14px;
    font-weight: 500;
    color: #475569;
    margin-bottom: 8px;
  }

  :global(.palette-node) {
    display: block !important;
    width: 100% !important;
    padding: 10px 15px !important;
    margin-bottom: 8px !important;
    background: #3b82f6 !important;
    color: white !important;
    border: none !important;
    border-radius: 8px !important;
    font-size: 14px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    text-align: center !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
  }

  :global(.palette-node:hover) {
    transform: translateY(-2px) !important;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4) !important;
    background: #2563eb !important;
  }

  :global(.palette-node:active) {
    transform: translateY(0px) !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2) !important;
  }

  :global(.page-title) {
    font-weight: 700 !important;
    font-size: 18px !important;
    color: #1e40af !important;
    margin-bottom: 16px !important;
    padding: 12px 0 !important;
    text-align: center !important;
    border-bottom: 3px solid #3b82f6 !important;
    text-transform: uppercase !important;
    letter-spacing: 0.5px !important;
  }

  :global(.palette-nav) {
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    margin-bottom: 16px !important;
    padding: 8px 0 !important;
  }

  :global(.nav-btn) {
    padding: 8px 16px !important;
    background: #f8fafc !important;
    border: 2px solid #e2e8f0 !important;
    border-radius: 6px !important;
    cursor: pointer !important;
    font-weight: 500 !important;
    color: #475569 !important;
    transition: all 0.2s !important;
  }

  :global(.nav-btn:hover) {
    background: #667eea !important;
    border-color: #667eea !important;
    color: white !important;
    transform: translateY(-1px) !important;
  }

  :global(.nav-btn:disabled) {
    opacity: 0.5 !important;
    cursor: not-allowed !important;
    transform: none !important;
  }

  :global(.page-indicator) {
    font-weight: 600 !important;
    color: #374151 !important;
    background: #f1f5f9 !important;
    padding: 6px 12px !important;
    border-radius: 20px !important;
    font-size: 12px !important;
  }

  :global(.page-btn) {
    padding: 8px 12px !important;
    background: #f8fafc !important;
    border: 2px solid #e2e8f0 !important;
    border-radius: 6px !important;
    cursor: pointer !important;
    font-weight: 600 !important;
    color: #475569 !important;
    font-size: 16px !important;
    transition: all 0.2s !important;
    width: 40px !important;
    height: 36px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
  }

  :global(.page-btn:hover) {
    background: #3b82f6 !important;
    border-color: #3b82f6 !important;
    color: white !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3) !important;
  }

  :global(.page-btn:disabled) {
    opacity: 0.4 !important;
    cursor: not-allowed !important;
    transform: none !important;
    background: #f1f5f9 !important;
    border-color: #e2e8f0 !important;
  }

  :global(.page-controls) {
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    margin-bottom: 16px !important;
    padding: 8px !important;
    background: #ffffff !important;
    border-radius: 8px !important;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
  }

  :global(.component-edit-btn) {
    background: #f59e0b !important;
    border: none !important;
    border-radius: 4px !important;
    color: white !important;
    cursor: pointer !important;
    font-size: 12px !important;
    margin-left: 8px !important;
    padding: 4px 6px !important;
    transition: all 0.2s !important;
  }

  :global(.component-edit-btn:hover) {
    background: #d97706 !important;
    transform: scale(1.1) !important;
  }

  :global(.node-component) {
    background: #6366f1 !important;
    color: white !important;
  }

  :global(.node-conditional) {
    background: #ec4899 !important;
    color: white !important;
  }

  :global(.node-component-input) {
    background: #10b981 !important;
    color: white !important;
    border: 2px solid #059669 !important;
    font-weight: 600 !important;
  }

  :global(.node-component-output) {
    background: #f59e0b !important;
    color: white !important;
    border: 2px solid #d97706 !important;
    font-weight: 600 !important;
  }

  .canvas {
    flex: 1;
    position: relative;
    overflow: visible;
    background: linear-gradient(
      to right,
      rgba(148, 163, 184, 0.1) 1px,
      transparent 1px
    ),
    linear-gradient(
      to bottom,
      rgba(148, 163, 184, 0.1) 1px,
      transparent 1px
    );
    background-size: 20px 20px;
  }

  /* Global styles for dynamically created elements */
  :global(.node) {
    position: absolute;
    min-width: 80px;
    padding: 8px 12px;
    background: white;
    border: 2px solid #cbd5e1;
    border-radius: 6px;
    cursor: move;
    user-select: none;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: all 0.2s;
    font-size: 14px;
    font-weight: 500;
    z-index: 10;
  }

  :global(.node:hover) {
    border-color: #3b82f6;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
  }

  :global(.node.selected) {
    border-color: #3b82f6;
    background: #eff6ff;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
  }

  :global(.node-number), :global(.node-variable) {
    border-color: #10b981;
    background: #f0fdf4;
  }

  :global(.node-add), :global(.node-subtract), :global(.node-multiply), :global(.node-divide), :global(.node-power) {
    border-color: #f59e0b;
    background: #fffbeb;
  }

  :global(.node-output) {
    border-color: #8b5cf6;
    background: #faf5ff;
  }

  :global(.port) {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #3b82f6;
    border: 2px solid white;
    border-radius: 50%;
    cursor: crosshair;
    z-index: 20;
    transition: all 0.2s;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
  }

  :global(.input-port) {
    left: -7px;
    background: #10b981;
  }

  :global(.output-port) {
    right: -7px;
    background: #f59e0b;
  }

  :global(.port:hover) {
    transform: scale(1.4);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
  }

  :global(.input-port:hover) {
    background: #059669;
  }

  :global(.output-port:hover) {
    background: #d97706;
  }

  @keyframes pulse {
    0%, 100% {
      transform: scale(1.4);
      opacity: 1;
    }
    50% {
      transform: scale(1.6);
      opacity: 0.8;
    }
  }

  .connections {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 5;
    opacity: 1;
    visibility: visible;
    display: block;
  }

  :global(.connections path) {
    pointer-events: stroke;
    stroke-width: 3px;
    stroke: #3b82f6;
  }

  :global(.connections path:hover) {
    stroke: #1d4ed8 !important;
    stroke-width: 3;
  }

  :global(.node-content) {
    pointer-events: none;
  }

  .equation-display {
    position: absolute;
    bottom: 16px;
    left: 16px;
    right: 16px;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    padding: 12px;
    font-family: 'Courier New', monospace;
    font-size: 16px;
    min-height: 40px;
    display: flex;
    align-items: center;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .sidebar {
    position: fixed;
    top: 0;
    right: -300px;
    width: 300px;
    height: 100vh;
    background: white;
    border-left: 1px solid #e2e8f0;
    box-shadow: -4px 0 8px rgba(0, 0, 0, 0.1);
    transition: right 0.3s ease;
    z-index: 1001;
    padding: 20px;
    overflow-y: auto;
  }

  .sidebar.open {
    right: 0;
  }

  .sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 12px;
    border-bottom: 1px solid #e2e8f0;
  }

  .sidebar-header h3 {
    font-size: 18px;
    font-weight: 600;
    color: #1e293b;
  }

  .close-btn {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: #64748b;
    padding: 4px;
    border-radius: 4px;
  }

  .close-btn:hover {
    background: #f1f5f9;
    color: #1e293b;
  }

  .input-group {
    margin-bottom: 16px;
  }

  .input-group label {
    display: block;
    font-size: 14px;
    font-weight: 500;
    color: #374151;
    margin-bottom: 6px;
  }

  .input-group input {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #d1d5db;
    border-radius: 4px;
    font-size: 14px;
  }

  .input-group input:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  .delete-btn {
    background: #ef4444;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    margin-top: 12px;
    width: 100%;
  }

  .delete-btn:hover {
    background: #dc2626;
  }
</style>
