---
import Layout from '../layouts/Layout.astro';
---

<Layout 
  title="Equation Builder - Ashton Andrepont"
  description="Clean, simple visual equation builder - drag and connect nodes to create mathematical expressions"
>
  <!-- KaTeX CSS and JS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
  <section class="section">
    <h2>Visual Equation Builder</h2>
    <p>A clean, simple approach to visual equation building. Click nodes to add them, then click and drag to connect and build mathematical expressions.</p>
  </section>

  <!-- Toolbar -->
  <div class="equation-toolbar">
    <button class="toolbar-btn" id="show-tables-btn" title="Show Variables & Equations Tables">Show Tables</button>
    <div class="toolbar-divider"></div>
    <button class="toolbar-btn export-btn" id="export-session-btn" title="Export Session as File">Export</button>
    <button class="toolbar-btn import-btn" id="import-session-btn" title="Import Session from File">Import</button>
    <button class="toolbar-btn clear-btn" id="clear-canvas-btn" title="Clear Canvas">Clear</button>
    <div class="auto-save-indicator" id="auto-save-indicator">
      <span class="auto-save-dot"></span>
      <span class="auto-save-text">Auto-saved</span>
    </div>
  </div>
  
  <!-- Hidden file input for imports -->
  <input type="file" id="import-file-input" accept=".json" style="display: none;">

  <!-- Clean equation builder interface -->
  <div class="equation-builder">
    <!-- Node Palette -->
    <div class="node-palette">
      <div class="palette-header">
        <h3>Node Library</h3>
        <div class="page-controls">
          <button class="page-btn" id="prev-page">‹</button>
          <span class="page-indicator" id="page-indicator">1 / 4</span>
          <button class="page-btn" id="next-page">›</button>

        </div>
      </div>
      
      <div class="palette-content" id="palette-content">
        <!-- Pages will be dynamically generated -->
      </div>
      
      <!-- Help Button at bottom of sidebar -->
      <div class="palette-footer">
        <button class="help-button" id="help-button" title="Node Reference Manual">?</button>
      </div>
    </div>

    <!-- Canvas -->
    <div class="canvas" id="equation-canvas">
      <svg class="connections" id="connections-svg" width="100%" height="100%"></svg>
      
      <!-- Selection Status -->
      <div class="selection-status" id="selection-status" style="display: none;">
        <span class="selection-count">0 nodes selected</span>
        <div class="selection-actions">
          <button class="selection-btn" id="group-selected" title="Group Selected (Ctrl+G)">Group</button>
          <button class="selection-btn" id="copy-selected" title="Copy (Ctrl+C)">Copy</button>
          <button class="selection-btn" id="cut-selected" title="Cut (Ctrl+X)">Cut</button>
          <button class="selection-btn danger" id="delete-selected" title="Delete (Del)">Delete</button>
        </div>
      </div>

    <!-- Equation Display -->
      <div class="equation-display" id="equation-display">
        Click nodes above to add them to the canvas...
      </div>
    </div>
  </div>

  <!-- Property Sidebar -->
  <div class="sidebar" id="property-sidebar">
    <div class="sidebar-header">
      <h3 id="sidebar-title">Node Properties</h3>
      <button class="close-btn" id="close-sidebar">×</button>
    </div>
    <div class="sidebar-content" id="sidebar-content">
      Select a node to edit its properties
    </div>
  </div>



  <!-- Help Modal -->
  <div class="help-modal" id="help-modal">
    <div class="help-content">
      <div class="help-header">
        <h2>Node Reference Manual</h2>
        <div class="help-nav">
          <div class="help-page-controls">
            <button class="help-page-btn" id="help-prev-page">‹</button>
            <span class="help-page-indicator" id="help-page-indicator">1 / 6</span>
            <button class="help-page-btn" id="help-next-page">›</button>
          </div>
          <button class="close-btn" id="close-help">×</button>
        </div>
      </div>
      <div class="help-body" id="help-body">
        <!-- Help content will be populated by JavaScript -->
      </div>
    </div>
  </div>

  <!-- Tables Sidebar -->
  <div class="tables-sidebar" id="tables-sidebar">
    <div class="tables-sidebar-header">
      <h3>Variables & Equations</h3>
      <button class="close-btn" id="close-tables-sidebar">×</button>
    </div>
    
    <!-- Variables Section -->
    <div class="table-section">
      <div class="section-header">
        <h4>Variables</h4>
        <button class="section-toggle" id="toggle-variables">−</button>
      </div>
      <div class="section-content" id="variables-section">
        <table class="variables-table">
          <thead>
            <tr>
              <th>Variable</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody id="variables-tbody">
            <!-- Variables will be populated by JavaScript -->
          </tbody>
        </table>
      </div>
    </div>
    
    <!-- Equations Section -->
    <div class="table-section">
      <div class="section-header">
        <h4>Equations</h4>
        <button class="section-toggle" id="toggle-equations">−</button>
      </div>
      <div class="section-content" id="equations-section">
        <table class="equations-table">
          <thead>
            <tr>
              <th>Name</th>
              <th>Equation</th>
              <th>Output</th>
            </tr>
          </thead>
          <tbody id="equations-tbody">
            <!-- Equations will be populated by JavaScript -->
          </tbody>
        </table>
      </div>
    </div>
  </div>
</Layout>

<script>
  // Clean Equation Builder - Vanilla JavaScript Implementation
  class CleanEquationBuilder {
    constructor() {
      this.nodes = new Map();
      this.connections = [];
      this.selectedNode = null;
      this.dragState = { isDragging: false, nodeId: null, offset: { x: 0, y: 0 } };
      this.connecting = { from: null, to: null };
      this.nodeCounter = 0;
      this.isEditingComponent = false;
      this.currentComponentId = null;
      
      // Enhanced interaction states
      this.connectionDrag = {
        isDragging: false,
        startPort: null,
        tempLine: null,
        startX: 0,
        startY: 0
      };
      this.nodeDrag = {
        isDragging: false,
        nodeType: null,
        dragElement: null,
        offsetX: 0,
        offsetY: 0
      };
      this.canvasClickState = {
        lastClickTime: 0,
        clickTimeout: null,
        clickCount: 0
      };
      
      // Global variable and output management
      this.globalVariables = new Map(); // variable name -> {value, isSet, inTable}
      this.globalOutputs = new Map(); // output node id -> {name, equation, result, inTable}
      this.originalNodePages = null;
      this.originalCurrentPage = 0;
      this.currentPage = 0;
      this.mainCanvasBackup = null;
      this.nodePages = [];
      
      // Multi-selection system
      this.selectedNodes = new Set(); // Set of selected node IDs
      this.selectionRectangle = null; // For drag-to-select functionality
      this.clipboard = null; // Stores copied/cut nodes and connections
      this.isDragSelecting = false;
      this.dragStartX = 0;
      this.dragStartY = 0;
      this.justFinishedDragSelection = false;
      
      this.canvas = document.getElementById('equation-canvas');
      this.sidebar = document.getElementById('property-sidebar');
      this.equationDisplay = document.getElementById('equation-display');
      this.connectionsSvg = document.getElementById('connections-svg');
      
      this.init();
    }

    init() {
      this.setupPalette();
      this.setupEventListeners();
      this.setupHelpModal();
      this.setupTables();
      this.setupMultiSelection();
    }
    
    setupPalette() {
      this.nodePages = [
        {
          title: 'Basic',
          nodes: [
            { type: 'number', label: 'Number' },
            { type: 'variable', label: 'Variable' },
            { type: 'add', label: '+' },
            { type: 'subtract', label: '−' },
            { type: 'multiply', label: '×' },
            { type: 'divide', label: '÷' },
            { type: 'output', label: 'Output' }
          ]
        },
        {
          title: 'Advanced Operations',
          nodes: [
            { type: 'power', label: '^' },
            { type: 'modulo', label: '%' },
            { type: 'sqrt', label: '√' },
            { type: 'abs', label: '|x|' },
            { type: 'log', label: 'log' },
            { type: 'ln', label: 'ln' }
          ]
        },
        {
          title: 'Trigonometry',
          nodes: [
            { type: 'sin', label: 'sin' },
            { type: 'cos', label: 'cos' },
            { type: 'tan', label: 'tan' }
          ]
        },
        {
          title: 'Constants',
          nodes: [
            { type: 'constant_pi', label: 'π' },
            { type: 'constant_e', label: 'e' },
            { type: 'constant_phi', label: 'φ' },
            { type: 'constant_sqrt2', label: '√2' }
          ]
        },
        {
          title: 'Comparison',
          nodes: [
            { type: 'equals', label: '=' },
            { type: 'greater', label: '>' },
            { type: 'less', label: '<' },
            { type: 'greaterEqual', label: '≥' },
            { type: 'lessEqual', label: '≤' },
            { type: 'notEqual', label: '≠' }
          ]
        },
        {
          title: 'Advanced',
          nodes: [
            { type: 'component', label: 'Component' },
            { type: 'conditional', label: 'Conditional' },
            { type: 'multiplexer', label: 'Multiplexer' },
            { type: 'splitter', label: 'Splitter' }
          ]
        }
      ];
      
      this.currentPage = 0;
      this.renderPalettePage();
    }
    
    renderPalettePage() {
      const page = this.nodePages[this.currentPage];
      const content = document.getElementById('palette-content');
      
      content.innerHTML = `
        <div class="palette-page">
          <div class="page-title">${page.title}</div>
          ${page.nodes.map(node => `
            <button class="palette-node" data-node-type="${node.type}">
              ${node.label}
            </button>
          `).join('')}
        </div>
      `;
      
      // Update page indicator
      document.getElementById('page-indicator').textContent = 
        `${this.currentPage + 1} / ${this.nodePages.length}`;
      
      // Update navigation button states
      document.getElementById('prev-page').disabled = this.currentPage === 0;
      document.getElementById('next-page').disabled = this.currentPage === this.nodePages.length - 1;
      
      // Add enhanced event listeners to new buttons with drag-and-drop support
      // Use requestAnimationFrame to ensure DOM is fully rendered before attaching listeners
      requestAnimationFrame(() => {
        content.querySelectorAll('.palette-node').forEach(btn => {
          this.setupPaletteNodeDragDrop(btn);
        });
      });
    }

    setupEventListeners() {
      // Page navigation
      document.getElementById('prev-page').addEventListener('click', () => {
        if (this.currentPage > 0) {
          this.currentPage--;
          this.renderPalettePage();
        }
      });
      
      document.getElementById('next-page').addEventListener('click', () => {
        if (this.currentPage < this.nodePages.length - 1) {
          this.currentPage++;
          this.renderPalettePage();
        }
      });
      
      // Initialize palette event listeners
      this.updatePaletteEventListeners();
    }

    updatePaletteEventListeners() {
      // Clear existing listeners and add new ones for current page
      document.querySelectorAll('.palette-node').forEach(btn => {
        // Clone to remove existing listeners
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);
        
        // Add click listener
        newBtn.addEventListener('click', (e) => {
          const nodeType = e.target.dataset.nodeType;
          const rect = this.canvas.getBoundingClientRect();
          
          // Create position that snaps to grid
          const gridSize = 20;
          const rawX = Math.random() * (rect.width - 150) + 50;
          const rawY = Math.random() * (rect.height - 150) + 50;
          
          const position = {
            x: Math.round(rawX / gridSize) * gridSize,
            y: Math.round(rawY / gridSize) * gridSize
          };
          
          this.addNode(nodeType, position);
        });
      });

      // Enhanced canvas events with right-click support for node menu
      this.canvas.addEventListener('click', (e) => {
        // Handle single clicks (deselect nodes and clear multi-selection)
        // But don't clear if we just finished a drag selection
        if ((e.target === this.canvas || e.target === this.connectionsSvg) && !this.justFinishedDragSelection) {
          this.deselectAll();
          this.clearSelection();
        }
        // Reset the flag
        this.justFinishedDragSelection = false;
      });
      
      // Right-click context menu for node creation
      this.canvas.addEventListener('contextmenu', (e) => {
        this.handleCanvasRightClick(e);
      });

      // Sidebar close
      document.getElementById('close-sidebar').addEventListener('click', () => {
        this.closeSidebar();
      });

      // Global mouse events for dragging
      document.addEventListener('mousemove', this.handleMouseMove.bind(this));
      document.addEventListener('mouseup', this.handleMouseUp.bind(this));
    }

    // Help Modal Management
    setupHelpModal() {
      this.currentHelpPage = 0;
      this.helpPages = this.createHelpPages();

      const helpButton = document.getElementById('help-button');
      const helpModal = document.getElementById('help-modal');
      const closeHelp = document.getElementById('close-help');
      const helpPrevBtn = document.getElementById('help-prev-page');
      const helpNextBtn = document.getElementById('help-next-page');

      helpButton.addEventListener('click', () => {
        // Sync help page with current palette page
        this.currentHelpPage = this.currentPage;
        // Ensure we don't exceed help page bounds
        if (this.currentHelpPage >= this.helpPages.length) {
          this.currentHelpPage = 0;
        }
        this.renderHelpPage();
        helpModal.classList.add('active');
      });

      closeHelp.addEventListener('click', () => {
        helpModal.classList.remove('active');
      });

      helpModal.addEventListener('click', (e) => {
        if (e.target === helpModal) {
          helpModal.classList.remove('active');
        }
      });

      helpPrevBtn.addEventListener('click', () => {
        if (this.currentHelpPage > 0) {
          this.currentHelpPage--;
          this.renderHelpPage();
        }
      });

      helpNextBtn.addEventListener('click', () => {
        if (this.currentHelpPage < this.helpPages.length - 1) {
          this.currentHelpPage++;
          this.renderHelpPage();
        }
      });
    }

    createHelpPages() {
      return [
        {
          title: 'Basic',
          content: `
            <div class="help-section">
              <h3>Arithmetic Operators</h3>
              <div class="node-family">
                <p>Standard math operators with two inputs, one output:</p>
                <ul class="node-list">
                  <li><strong>+, -, ×, ÷</strong> - Basic arithmetic operations</li>
                </ul>
              </div>
              
              <h3>Input/Output</h3>
              <div class="node-family">
                <ul class="node-list">
                  <li><strong>Number</strong> - Configurable numeric value</li>
                  <li><strong>Variable</strong> - Named placeholder (x, y, etc.)</li>
                  <li><strong>Output</strong> - Shows equation output</li>
                </ul>
                <div class="help-tip">
                  <strong>Workflow:</strong> Add nodes from palette → connect output ports (right) to input ports (left) → click nodes to configure → add Output to see results.
                </div>
              </div>
            </div>
          `
        },
        {
          title: 'Advanced Operations',
          content: `
            <div class="help-section">
              <h3>Power & Root</h3>
              <div class="node-family">
                <ul class="node-list">
                  <li><strong>^ (Power)</strong> - Exponentiation</li>
                  <li><strong>% (Modulo)</strong> - Remainder division</li>
                  <li><strong>√ (Square Root)</strong> - Root calculation</li>
                  <li><strong>|x| (Absolute)</strong> - Absolute value</li>
                </ul>
              </div>
              
              <h3>Logarithms</h3>
              <div class="node-family">
                <ul class="node-list">
                  <li><strong>ln (Natural Log)</strong> - Base e logarithm</li>
                  <li><strong>log</strong> - Configurable base logarithm</li>
                </ul>
              </div>
            </div>
          `
        },
        {
          title: 'Trigonometry',
          content: `
            <div class="help-section">
              <h3>Trig Functions</h3>
              <div class="node-family">
                <p>All angles in radians:</p>
                <ul class="node-list">
                  <li><strong>sin, cos, tan</strong> - Basic trigonometric functions</li>
                  <li><strong>asin, acos, atan</strong> - Inverse functions (return angles)</li>
                </ul>
              </div>
            </div>
          `
        },
        {
          title: 'Constants',
          content: `
            <div class="help-section">
              <h3>Mathematical Constants</h3>
              <div class="node-family">
                <ul class="node-list">
                  <li><strong>π (Pi)</strong> - 3.14159...</li>
                  <li><strong>e (Euler)</strong> - 2.71828...</li>
                  <li><strong>φ (Golden Ratio)</strong> - 1.61803...</li>
                  <li><strong>√2 (Square Root of 2)</strong> - 1.41421...</li>
                </ul>
              </div>
            </div>
          `
        },
        {
          title: 'Comparison',
          content: `
            <div class="help-section">
              <h3>Comparison Operators</h3>
              <div class="node-family">
                <p>Return 1 (true) or 0 (false):</p>
                <ul class="node-list">
                  <li><strong>&gt;, &lt;, =</strong> - Greater than, less than, equals</li>
                </ul>
              </div>
              
              <h3>Conditional Logic</h3>
              <div class="node-family">
                <ul class="node-list">
                  <li><strong>Conditional</strong> - Rule-based decision making</li>
                </ul>
                <div class="help-tip">
                  <strong>Rules:</strong> Greater/less than, equals, range, negative/positive/zero checks, plus default fallback. Configure in sidebar.
                </div>
              </div>
            </div>
          `
        },
        {
          title: 'Advanced',
          content: `
            <div class="help-section">
              <h3>Data Routing</h3>
              <div class="node-family">
                <ul class="node-list">
                  <li><strong>Multiplexer</strong> - Select one input from many based on choice</li>
                  <li><strong>Splitter</strong> - Copy one input to multiple outputs</li>
                </ul>
                <div class="help-tip">
                  <strong>Configuration:</strong> Both support 2-10 ports. Click to configure in sidebar.
                </div>
              </div>
              
              <h3>Components</h3>
              <div class="node-family">
                <ul class="node-list">
                  <li><strong>Component</strong> - Reusable sub-equation with custom inputs/outputs</li>
                  <li><strong>Component Input/Output</strong> - Define component interface</li>
                </ul>
                <div class="help-tip">
                  <strong>Components:</strong> Double-click to edit internal workspace. Use Component Input/Output nodes to define external interface. Changes are saved automatically.
                </div>
              </div>
              
              <h3>Pro Tips</h3>
              <div class="node-family">
                <ul class="node-list">
                  <li>Components create reusable calculation modules</li>
                  <li>Use conditionals for complex logic branching</li>
                  <li>Splitters eliminate duplicate connections</li>
                  <li>Chain multiplexers for sophisticated routing</li>
                </ul>
              </div>
            </div>
          `
        }
      ];
    }

    renderHelpPage() {
      const helpBody = document.getElementById('help-body');
      const helpPageIndicator = document.getElementById('help-page-indicator');
      const helpPrevBtn = document.getElementById('help-prev-page');
      const helpNextBtn = document.getElementById('help-next-page');

      // Update content
      const currentPage = this.helpPages[this.currentHelpPage];
      helpBody.innerHTML = currentPage.content;

      // Update page indicator
      helpPageIndicator.textContent = `${this.currentHelpPage + 1} / ${this.helpPages.length}`;

      // Update button states
      helpPrevBtn.disabled = this.currentHelpPage === 0;
      helpNextBtn.disabled = this.currentHelpPage === this.helpPages.length - 1;
    }

    generateId() {
      return `node-${++this.nodeCounter}-${Date.now()}`;
    }

    addNode(type, position) {
      const id = this.generateId();
      
      const nodeConfigs = {
        // Generators
        number: { label: '5', value: 5, inputs: [], outputs: ['out'] },
        variable: { label: 'x', variable: 'x', inputs: [], outputs: ['out'] },
        constant_pi: { label: 'π', value: Math.PI, inputs: [], outputs: ['out'] },
        constant_e: { label: 'e', value: Math.E, inputs: [], outputs: ['out'] },
        constant_phi: { label: 'φ', value: (1 + Math.sqrt(5)) / 2, inputs: [], outputs: ['out'] }, // Golden ratio
        constant_sqrt2: { label: '√2', value: Math.sqrt(2), inputs: [], outputs: ['out'] },
        
        // Basic Operators
        add: { label: '+', inputs: ['in1', 'in2'], outputs: ['out'] },
        subtract: { label: '−', inputs: ['in1', 'in2'], outputs: ['out'] },
        multiply: { label: '×', inputs: ['in1', 'in2'], outputs: ['out'] },
        divide: { label: '÷', inputs: ['in1', 'in2'], outputs: ['out'] },
        power: { label: '^', inputs: ['base', 'exp'], outputs: ['out'] },
        modulo: { label: 'mod', inputs: ['in1', 'in2'], outputs: ['out'] },
        
        // Advanced Math
        sqrt: { label: '√', inputs: ['value', 'root'], outputs: ['out'] },
        log: { label: 'log', inputs: ['value', 'base'], outputs: ['out'] },
        ln: { label: 'ln', inputs: ['in'], outputs: ['out'] },
        abs: { label: '|x|', inputs: ['in'], outputs: ['out'] },
        
        // Trigonometry  
        sin: { label: 'sin', inputs: ['in'], outputs: ['out'] },
        cos: { label: 'cos', inputs: ['in'], outputs: ['out'] },
        tan: { label: 'tan', inputs: ['in'], outputs: ['out'] },
        
        // Comparison
        equals: { label: '=', inputs: ['in1', 'in2'], outputs: ['out'] },
        greater: { label: '>', inputs: ['in1', 'in2'], outputs: ['out'] },
        less: { label: '<', inputs: ['in1', 'in2'], outputs: ['out'] },
        greaterEqual: { label: '≥', inputs: ['in1', 'in2'], outputs: ['out'] },
        lessEqual: { label: '≤', inputs: ['in1', 'in2'], outputs: ['out'] },
        notEqual: { label: '≠', inputs: ['in1', 'in2'], outputs: ['out'] },
        
        // Component I/O (for sub-equation editing)
        componentInput: { label: 'Input', inputs: [], outputs: ['out'], componentIO: true },
        componentOutput: { label: 'Output', inputs: ['in'], outputs: [], componentIO: true },
        
        // Advanced Components
        component: { label: 'Component', inputs: [], outputs: [], customizable: true },
        conditional: { label: 'Conditional', inputs: ['value'], outputs: ['output'] },
        multiplexer: { label: 'Multiplexer', inputs: ['choice0', 'choice1', 'selector'], outputs: ['output'], customizable: true },
        splitter: { label: 'Splitter', inputs: ['input'], outputs: ['output0', 'output1'], customizable: true },
        
        // Output
        output: { label: 'Output', inputs: ['in'], outputs: [] }
      };

      const config = nodeConfigs[type];
      const node = {
        id,
        type,
        position,
        ...config
      };

      this.nodes.set(id, node);
      this.renderNode(node);
      this.updateEquation();
      
      // If we're on the main canvas and have a backup, update it
      if (!this.isEditingComponent && this.mainCanvasBackup) {
        this.mainCanvasBackup.nodes.set(id, node);
      }
      
      // Handle component I/O nodes - update parent component ports
      if (node.componentIO && this.isEditingComponent) {
        this.updateParentComponentPorts();
      }
    }

    renderNode(node) {
      const nodeEl = document.createElement('div');
      nodeEl.className = `node node-${node.type}`;
      nodeEl.id = node.id;
      
      // Add special styling for advanced components
      if (node.type === 'component') {
        nodeEl.classList.add('node-component');
      } else if (node.type === 'conditional') {
        nodeEl.classList.add('node-conditional');
      } else if (node.type === 'componentInput') {
        nodeEl.classList.add('node-component-input');
      } else if (node.type === 'componentOutput') {
        nodeEl.classList.add('node-component-output');
      } else if (node.type === 'multiplexer') {
        nodeEl.classList.add('node-multiplexer');
      } else if (node.type === 'splitter') {
        nodeEl.classList.add('node-splitter');
      }
      
      // Explicit positioning and base styles to ensure visibility
      // Apply base node class and set position via style (position needs to be dynamic)
      nodeEl.classList.add('equation-node');
      nodeEl.style.left = `${node.position.x}px`;
      nodeEl.style.top = `${node.position.y}px`;
      
      // Special handling for component nodes
      if (node.type === 'component') {
        nodeEl.innerHTML = `
          <div class="node-content">
            ${node.label}
          </div>
          ${(node.inputs || []).map((input, i) => `
            <div class="port input-port" data-port="${input}" data-node="${node.id}" data-port-index="${i}" data-total-ports="${(node.inputs || []).length}" data-tooltip="${this.getPortLabel(node.type, input, 'input')}" style="position: absolute; left: -7px; width: 12px; height: 12px; background: #10b981; border: 2px solid white; border-radius: 50%; cursor: crosshair; z-index: 30; pointer-events: auto;"></div>
          `).join('')}
          ${(node.outputs || []).map((output, i) => `
            <div class="port output-port" data-port="${output}" data-node="${node.id}" data-port-index="${i}" data-total-ports="${(node.outputs || []).length}" data-tooltip="${this.getPortLabel(node.type, output, 'output')}" style="position: absolute; right: -7px; width: 12px; height: 12px; background: #f59e0b; border: 2px solid white; border-radius: 50%; cursor: crosshair; z-index: 30; pointer-events: auto;"></div>
          `).join('')}
        `;
      } else {
        nodeEl.innerHTML = `
          <div class="node-content">${node.label}</div>
          ${(node.inputs || []).map((input, i) => `
            <div class="port input-port" data-port="${input}" data-node="${node.id}" data-port-index="${i}" data-total-ports="${(node.inputs || []).length}" data-tooltip="${this.getPortLabel(node.type, input, 'input')}" style="position: absolute; left: -7px; width: 12px; height: 12px; background: #10b981; border: 2px solid white; border-radius: 50%; cursor: crosshair; z-index: 30; pointer-events: auto;"></div>
          `).join('')}
          ${(node.outputs || []).map((output, i) => `
            <div class="port output-port" data-port="${output}" data-node="${node.id}" data-port-index="${i}" data-total-ports="${(node.outputs || []).length}" data-tooltip="${this.getPortLabel(node.type, output, 'output')}" style="position: absolute; right: -7px; width: 12px; height: 12px; background: #f59e0b; border: 2px solid white; border-radius: 50%; cursor: crosshair; z-index: 30; pointer-events: auto;"></div>
          `).join('')}
        `;
      }
      
      // Add event listeners
      nodeEl.addEventListener('mousedown', (e) => this.handleNodeMouseDown(e, node.id));
      nodeEl.addEventListener('click', (e) => {
        e.stopPropagation();
        
        // Multi-selection support
        if (e.ctrlKey || e.metaKey) {
          this.toggleNodeSelection(node.id, true);
        } else {
          // Traditional single selection (also opens sidebar)
          this.toggleNodeSelection(node.id, false);
          this.selectNode(node.id);
        }
      });



      // Enhanced port click events with drag support
      nodeEl.querySelectorAll('.port').forEach(port => {
        this.setupEnhancedPortHandlers(port, nodeEl);
      });

      this.canvas.appendChild(nodeEl);
      
      // Position ports evenly after node is rendered
      this.positionPortsEvenly(nodeEl, node);
    }

    getPortLabel(nodeType, portName, portType) {
      const portLabels = {
        // Basic nodes
        number: { out: 'Number Value' },
        variable: { out: 'Variable Value' },
        output: { in: 'Final Output' },
        
        // Arithmetic  
        add: { in1: 'First Number', in2: 'Second Number', out: 'Sum' },
        subtract: { in1: 'Minuend', in2: 'Subtrahend', out: 'Difference' },
        multiply: { in1: 'Multiplicand', in2: 'Multiplier', out: 'Product' },
        divide: { in1: 'Dividend', in2: 'Divisor', out: 'Quotient' },
        power: { base: 'Base Number', exp: 'Exponent', out: 'Result' },
        modulo: { in1: 'Dividend', in2: 'Modulus', out: 'Remainder' },
        
        // Advanced Math
        sqrt: { value: 'Value to Root', root: 'Root Degree (default: 2)', out: 'Root Result' },
        log: { value: 'Value for Log', base: 'Log Base (default: 10)', out: 'Logarithm' },
        ln: { in: 'Value for Natural Log', out: 'Natural Logarithm' },
        abs: { in: 'Value for Absolute', out: 'Absolute Value' },
        
        // Trigonometry
        sin: { in: 'Angle (radians)', out: 'Sine' },
        cos: { in: 'Angle (radians)', out: 'Cosine' },
        tan: { in: 'Angle (radians)', out: 'Tangent' },
        
        // Constants
        pi: { out: 'Pi (π ≈ 3.14159)' },
        e: { out: 'Euler Number (e ≈ 2.71828)' },
        
        // Comparison
        equals: { in1: 'Left Value', in2: 'Right Value', out: 'Equality (1/0)' },
        greater: { in1: 'Left Value', in2: 'Right Value', out: 'Greater Than (1/0)' },
        less: { in1: 'Left Value', in2: 'Right Value', out: 'Less Than (1/0)' },
        greaterEqual: { in1: 'Left Value', in2: 'Right Value', out: 'Greater/Equal (1/0)' },
        lessEqual: { in1: 'Left Value', in2: 'Right Value', out: 'Less/Equal (1/0)' },
        notEqual: { in1: 'Left Value', in2: 'Right Value', out: 'Not Equal (1/0)' },
        
        // Component I/O
        componentInput: { out: 'Input Data to Component' },
        componentOutput: { in: 'Result from Component Logic' },
        
        // Advanced Components
        component: { out: 'Component Output' },
        conditional: { 
          value: 'Input Value to Check', 
          output: 'Output Based on Rules'
        },
        multiplexer: {
          selector: 'Selector (bottom port: 0, 1, 2, etc.)',
          choice0: 'Choice 0 (when selector=0)',
          choice1: 'Choice 1 (when selector=1)',
          choice2: 'Choice 2 (when selector=2)',
          choice3: 'Choice 3 (when selector=3)',
          choice4: 'Choice 4 (when selector=4)',
          choice5: 'Choice 5 (when selector=5)',
          choice6: 'Choice 6 (when selector=6)',
          choice7: 'Choice 7 (when selector=7)',
          choice8: 'Choice 8 (when selector=8)',
          choice9: 'Choice 9 (when selector=9)',
          output: 'Selected Choice Value'
        },
        splitter: {
          input: 'Input Value to Split',
          output0: 'Copy 0 of Input',
          output1: 'Copy 1 of Input', 
          output2: 'Copy 2 of Input',
          output3: 'Copy 3 of Input',
          output4: 'Copy 4 of Input',
          output5: 'Copy 5 of Input',
          output6: 'Copy 6 of Input',
          output7: 'Copy 7 of Input',
          output8: 'Copy 8 of Input',
          output9: 'Copy 9 of Input'
        }
      };
      
      const nodeLabels = portLabels[nodeType];
      if (!nodeLabels) return `${portType}: ${portName}`;
      
      const label = nodeLabels[portName];
      return label ? `${portType}: ${label}` : `${portType}: ${portName}`;
    };

    showTooltip(event, text) {
      // Remove existing tooltip
      this.hideTooltip();
      
      const tooltip = document.createElement('div');
      tooltip.id = 'port-tooltip';
      tooltip.textContent = text;
      tooltip.style.cssText = `
        position: fixed;
        background: #1f2937;
        color: white;
        padding: 6px 10px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
        pointer-events: none;
        z-index: 1000;
        white-space: nowrap;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        left: ${event.clientX + 10}px;
        top: ${event.clientY - 30}px;
      `;
      
      document.body.appendChild(tooltip);
    }

    hideTooltip() {
      const existing = document.getElementById('port-tooltip');
      if (existing) {
        existing.remove();
      }
    }

    openComponentEditor(nodeId) {
      // Prevent entering component editing mode if already editing
      if (this.isEditingComponent) {
        return;
      }
      
      // Enter component editing mode in main canvas
      this.isEditingComponent = true;
      this.currentComponentId = nodeId;
      
      // Backup main canvas state
      this.mainCanvasBackup = {
        nodes: new Map(this.nodes),
        connections: [...this.connections]
      };
      
      // Store original palette pages and switch to component palette
      this.originalNodePages = this.nodePages;
      this.originalCurrentPage = this.currentPage;
      
      // Set component-specific node palette - full access to all tools
      this.nodePages = [
        {
          title: 'Component I/O',
          nodes: [
            { type: 'componentInput', label: 'Input' },
            { type: 'componentOutput', label: 'Output' }
          ]
        },
        {
          title: 'Basic',
          nodes: [
            { type: 'number', label: 'Number' },
            { type: 'variable', label: 'Variable' },
            { type: 'add', label: '+' },
            { type: 'subtract', label: '−' },
            { type: 'multiply', label: '×' },
            { type: 'divide', label: '÷' }
          ]
        },
        {
          title: 'Advanced Operations',
          nodes: [
            { type: 'power', label: '^' },
            { type: 'modulo', label: '%' },
            { type: 'sqrt', label: '√' },
            { type: 'abs', label: '|x|' },
            { type: 'log', label: 'log' },
            { type: 'ln', label: 'ln' }
          ]
        },
        {
          title: 'Trigonometry',
          nodes: [
            { type: 'sin', label: 'sin' },
            { type: 'cos', label: 'cos' },
            { type: 'tan', label: 'tan' }
          ]
        },
        {
          title: 'Constants',
          nodes: [
            { type: 'constant_pi', label: 'π' },
            { type: 'constant_e', label: 'e' },
            { type: 'constant_phi', label: 'φ' },
            { type: 'constant_sqrt2', label: '√2' }
          ]
        },
        {
          title: 'Comparison',
          nodes: [
            { type: 'equals', label: '=' },
            { type: 'greater', label: '>' },
            { type: 'less', label: '<' },
            { type: 'greaterEqual', label: '≥' },
            { type: 'lessEqual', label: '≤' },
            { type: 'notEqual', label: '≠' }
          ]
        }
      ];
      this.currentPage = 0;
      
      // Clear main canvas and show component editing UI
      this.clearCanvas();
      this.setComponentEditingMode(true);
      this.renderPalettePage();
      this.showComponentEditingOverlay(nodeId);
      
      // Initialize component workspace data if needed
      if (!window.componentData) {
        window.componentData = {};
      }
      if (!window.componentData[nodeId]) {
        window.componentData[nodeId] = {
          nodes: new Map(),
          connections: [],
          nodeCounter: 0
        };
      }
      
      // Load component's existing nodes if any
      this.loadComponentNodes(nodeId);
    }

    setComponentEditingMode(enabled) {
      // Change canvas background to distinguish component editing mode
      if (enabled) {
        this.canvas.style.background = `
          linear-gradient(90deg, rgba(139, 69, 19, 0.1) 0px, transparent 1px),
          linear-gradient(rgba(139, 69, 19, 0.1) 0px, transparent 1px),
          linear-gradient(45deg, rgba(139, 69, 19, 0.05) 25%, transparent 25%),
          linear-gradient(-45deg, rgba(139, 69, 19, 0.05) 25%, transparent 25%)
        `;
        this.canvas.style.backgroundSize = '20px 20px, 20px 20px, 40px 40px, 40px 40px';
      } else {
        // Restore original background
        this.canvas.style.background = `
          linear-gradient(90deg, rgba(99, 102, 241, 0.05) 0px, transparent 1px),
          linear-gradient(rgba(99, 102, 241, 0.05) 0px, transparent 1px)
        `;
        this.canvas.style.backgroundSize = '20px 20px';
      }
    }

    showComponentEditingOverlay(nodeId) {
      // Add component editing header overlay
      const existingOverlay = document.getElementById('component-editing-overlay');
      if (existingOverlay) existingOverlay.remove();
      
      const overlay = document.createElement('div');
      overlay.id = 'component-editing-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: #3b82f6;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        display: flex;
        align-items: center;
        gap: 16px;
        z-index: 1000;
      `;
      
      const node = Array.from(this.nodes.values()).find(n => n.id === nodeId);
      const componentName = node ? (node.customName || node.label) : 'Component';
      
      overlay.innerHTML = `
        <span style="font-weight: 600;">Editing: ${componentName}</span>
        <input type="text" id="comp-name-input" value="${componentName}" placeholder="Component Name" style="
          padding: 4px 8px;
          border: none;
          border-radius: 4px;
          font-size: 14px;
          width: 150px;
        ">
        <button id="export-component" style="
          background: #8b5cf6;
          color: white;
          border: none;
          padding: 6px 12px;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 500;
          font-size: 13px;
        ">Export</button>
        <button id="import-component" style="
          background: #f59e0b;
          color: white;
          border: none;
          padding: 6px 12px;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 500;
          font-size: 13px;
        ">Import</button>
        <button id="save-component" style="
          background: #10b981;
          color: white;
          border: none;
          padding: 6px 12px;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 500;
        ">Save</button>
        <button id="cancel-component-edit" style="
          background: #ef4444;
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 600;
          font-size: 14px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        ">Exit Component</button>
      `;
      
      document.body.appendChild(overlay);
      
      // Add event listeners
      document.getElementById('export-component').addEventListener('click', (e) => {
        e.preventDefault();
        this.exportComponent();
      });
      
      document.getElementById('import-component').addEventListener('click', (e) => {
        e.preventDefault();
        this.importComponent();
      });
      
      document.getElementById('save-component').addEventListener('click', (e) => {
        e.preventDefault();
        this.saveComponentAndExit(nodeId);
      });
      
      document.getElementById('cancel-component-edit').addEventListener('click', (e) => {
        e.preventDefault();
        this.exitComponentEditingMode();
      });
      
      // Allow Enter key to save component name
      document.getElementById('comp-name-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          this.saveComponentAndExit(nodeId);
        }
      });
    }

    clearCanvas() {
      // Clear all nodes from main canvas
      const existingNodes = document.querySelectorAll('#equation-canvas > div');
      existingNodes.forEach(node => node.remove());
      
      // Clear connections
      this.connectionsSvg.innerHTML = '';
      
      // Clear data structures for full reset (used by session management)
      if (arguments.length > 0 && arguments[0] === 'full') {
        this.nodes.clear();
        this.connections = [];
        this.globalVariables.clear();
        this.globalOutputs.clear();
        
        // Clear tables
        this.updateVariablesTable();
        this.updateEquationsTable();
        
        // Reset drag and connection states
        this.dragState = { isDragging: false, nodeId: null, startX: 0, startY: 0 };
        this.connecting = { from: null, isConnecting: false };
      }
    }

    loadComponentNodes(nodeId) {
      const compData = window.componentData[nodeId];
      if (!compData) return;
      
      // Clear current nodes and load component's nodes
      this.nodes = new Map(compData.nodes);
      
      // Render component's nodes in main canvas
      compData.nodes.forEach(node => {
        this.renderNode(node);
      });
      
      // Restore component's connections
      this.connections = [...compData.connections];
      this.updateConnections();
    }

    saveComponentAndExit(nodeId) {
      // Save current canvas state to component data
      const compData = window.componentData[nodeId];
      compData.nodes = new Map(this.nodes);
      compData.connections = [...this.connections];
      
      // Update component name in the backed up main canvas
      const newName = document.getElementById('comp-name-input').value || 'Component';
      const backupNode = this.mainCanvasBackup.nodes.get(nodeId);
      if (backupNode) {
        backupNode.customName = newName;
        backupNode.label = newName;
      }
      
      this.exitComponentEditingMode();
    }

    exitComponentEditingMode() {
      // Update component ports before exiting
      const componentId = this.currentComponentId;
      if (componentId) {
        this.updateComponentPortsInBackup(componentId);
      }
      
      // Exit component editing mode
      this.isEditingComponent = false;
      this.currentComponentId = null;
      
      // Restore original palette
      this.nodePages = this.originalNodePages;
      this.currentPage = this.originalCurrentPage;
      this.renderPalettePage();
      
      // Restore canvas background
      this.setComponentEditingMode(false);
      
      // Clear canvas and restore main nodes
      this.clearCanvas();
      this.loadMainNodes();
      
      // Remove overlay
      const overlay = document.getElementById('component-editing-overlay');
      if (overlay) overlay.remove();
    }

    loadMainNodes() {
      // Restore main canvas nodes and connections from stored data
      if (this.mainCanvasBackup) {
        // Restore nodes
        this.nodes = new Map(this.mainCanvasBackup.nodes);
        this.mainCanvasBackup.nodes.forEach(node => {
          this.renderNode(node);
        });
        
        // Restore connections
        this.connections = [...this.mainCanvasBackup.connections];
      }
      
      // Update visual connections and refresh calculations
      this.updateConnections();
      this.updateEquation(); // Auto-update component calculations after saving
    }




















    
    positionPortsEvenly(nodeEl, node) {
      const nodeRect = nodeEl.getBoundingClientRect();
      const nodeHeight = nodeRect.height;
      const nodeWidth = nodeRect.width;
      
      // Special handling for multiplexer
      if (node.type === 'multiplexer') {
        const inputPorts = nodeEl.querySelectorAll('.input-port');
        const selectorPort = Array.from(inputPorts).find(port => port.dataset.port === 'selector');
        const choicePorts = Array.from(inputPorts).filter(port => port.dataset.port !== 'selector');
        
        // Position choice ports along left side
        choicePorts.forEach((port, i) => {
          const totalChoices = choicePorts.length;
          if (totalChoices === 1) {
            port.style.top = `${nodeHeight / 2 - 6}px`;
          } else {
            const spacing = nodeHeight / (totalChoices + 1);
            port.style.top = `${(i + 1) * spacing - 6}px`;
          }
        });
        
        // Position selector port at bottom center
        if (selectorPort) {
          selectorPort.style.left = `${nodeWidth / 2 - 6}px`; // Center horizontally
          selectorPort.style.top = `${nodeHeight - 7}px`; // Bottom edge
        }
      } else {
        // Standard positioning for all other nodes
        const inputPorts = nodeEl.querySelectorAll('.input-port');
        inputPorts.forEach((port, i) => {
          const totalPorts = inputPorts.length;
          if (totalPorts === 1) {
            port.style.top = `${nodeHeight / 2 - 6}px`; // Center single port (6px = half port height)
          } else {
            const spacing = nodeHeight / (totalPorts + 1);
            port.style.top = `${(i + 1) * spacing - 6}px`; // Evenly space ports
          }
        });
      }
      
      // Position output ports evenly along right side (same for all nodes)
      const outputPorts = nodeEl.querySelectorAll('.output-port');
      outputPorts.forEach((port, i) => {
        const totalPorts = outputPorts.length;
        if (totalPorts === 1) {
          port.style.top = `${nodeHeight / 2 - 6}px`; // Center single port
        } else {
          const spacing = nodeHeight / (totalPorts + 1);
          port.style.top = `${(i + 1) * spacing - 6}px`; // Evenly space ports
        }
      });
    }

    handleNodeMouseDown(e, nodeId) {
      e.preventDefault();
      const nodeEl = document.getElementById(nodeId);
      const rect = nodeEl.getBoundingClientRect();
      
      this.dragState = {
        isDragging: true,
        nodeId,
        offset: {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        }
      };
    }

    handleMouseMove(e) {
      // Handle existing node dragging
      if (this.dragState.isDragging && this.dragState.nodeId) {
        const canvasRect = this.canvas.getBoundingClientRect();
        let newPosition = {
          x: e.clientX - canvasRect.left - this.dragState.offset.x,
          y: e.clientY - canvasRect.top - this.dragState.offset.y
        };

        // Snap to grid (20px grid to match background)
        const gridSize = 20;
        newPosition.x = Math.round(newPosition.x / gridSize) * gridSize;
        newPosition.y = Math.round(newPosition.y / gridSize) * gridSize;

        // Constrain to canvas bounds
        newPosition.x = Math.max(10, Math.min(newPosition.x, canvasRect.width - 100));
        newPosition.y = Math.max(10, Math.min(newPosition.y, canvasRect.height - 50));

        const node = this.nodes.get(this.dragState.nodeId);
        if (node) {
          node.position = newPosition;
          const nodeEl = document.getElementById(node.id);
          
          // Disable transitions during drag for performance
          nodeEl.style.transition = 'none';
          nodeEl.style.left = `${newPosition.x}px`;
          nodeEl.style.top = `${newPosition.y}px`;
          
          this.updateConnections();
        }
      }
      
      // Handle connection dragging
      if (this.connectionDrag.isDragging) {
        this.updateConnectionDrag(e);
      }
    }

    handleMouseUp(e) {
      // Handle existing node dragging
      if (this.dragState.isDragging && this.dragState.nodeId) {
        const nodeEl = document.getElementById(this.dragState.nodeId);
        if (nodeEl) {
          nodeEl.style.transition = '';
        }
        this.dragState = { isDragging: false, nodeId: null, offset: { x: 0, y: 0 } };
      }
      
      // Handle connection dragging
      if (this.connectionDrag.isDragging) {
        this.completeConnectionDrag(e);
      }
    }

    handlePortClick(portId, nodeId, isOutput) {
      const portKey = `${nodeId}-${portId}`;

      
      if (this.connecting.from === null) {
        // Start connection from output port only
        if (isOutput) {
          this.connecting.from = portKey;
          this.showConnectionFeedback();
        }
      } else if (this.connecting.from !== portKey) {
        // Complete connection to input port only
        if (!isOutput) {
          console.log('✅ Completing connection:', this.connecting.from, '→', portKey);
          this.addConnection(this.connecting.from, portKey);
          console.log('🔗 Connection added. Total connections:', this.connections.length);
        } else {
          console.log('❌ Cannot connect output to output');
        }
        this.connecting = { from: null, to: null };
        this.hideConnectionFeedback();
      } else {
        // Cancel connection (clicking same port)
        console.log('🚫 Canceling connection');
        this.connecting = { from: null, to: null };
        this.hideConnectionFeedback();
      }
    }

    showConnectionFeedback() {
      // Highlight available input ports with pulsing animation
      document.querySelectorAll('.input-port').forEach(port => {
        port.style.background = '#10b981';
        port.style.transform = 'scale(1.4)';
        port.style.animation = 'pulse 1s infinite';
        port.style.boxShadow = '0 0 10px rgba(16, 185, 129, 0.6)';
      });
      
      // Dim output ports
      document.querySelectorAll('.output-port').forEach(port => {
        port.style.opacity = '0.3';
      });
    }

    hideConnectionFeedback() {
      // Reset all port styles
      document.querySelectorAll('.port').forEach(port => {
        port.style.background = '';
        port.style.transform = '';
        port.style.animation = '';
        port.style.boxShadow = '';
        port.style.opacity = '';
      });
    }

    addConnection(from, to) {
      console.log('🔗 addConnection called:', { from, to });
      
      // Prevent self-connection
      // Connection format is "nodeId-portId", need to extract nodeId properly
      const fromNodeId = from.substring(0, from.lastIndexOf('-'));
      const toNodeId = to.substring(0, to.lastIndexOf('-'));
      if (fromNodeId === toNodeId) {
        console.log('❌ Cannot connect node to itself');
        return;
      }
      
      // Check if connection already exists
      const exists = this.connections.some(conn => conn.from === from && conn.to === to);
      if (exists) {
        console.log('❌ Connection already exists');
        return;
      }

      const connection = {
        id: this.generateId(),
        from,
        to
      };
      this.connections.push(connection);
      console.log('✅ Connection added:', connection);
      console.log('📊 Total connections:', this.connections.length);
      
      // If we're on the main canvas and have a backup, update it
      if (!this.isEditingComponent && this.mainCanvasBackup) {
        this.mainCanvasBackup.connections.push(connection);
      }
      
      this.updateConnections();
      this.updateEquation();
      
      // Trigger auto-save after connection changes
      if (this.autoSaveCallback) {
        this.autoSaveCallback();
      }
    }

    // Connection dragging methods
    startConnectionDrag(port, event) {
      const portRect = port.getBoundingClientRect();
      const canvasRect = this.canvas.getBoundingClientRect();
      
      // Calculate port center position relative to canvas
      const portCenterX = portRect.left + portRect.width / 2 - canvasRect.left;
      const portCenterY = portRect.top + portRect.height / 2 - canvasRect.top;
      
      this.connectionDrag = {
        isDragging: true,
        startPort: port,
        startX: portCenterX,
        startY: portCenterY,
        tempLine: null
      };
      
      // Create temporary SVG line for visual feedback
      this.createTempConnectionLine(portCenterX, portCenterY, event.clientX - canvasRect.left, event.clientY - canvasRect.top);
      
      // Show connection feedback
      this.showConnectionFeedback();
      
      // Set cursor style
      document.body.style.cursor = 'crosshair';
    }

    createTempConnectionLine(startX, startY, endX, endY) {
      // Remove existing temp line
      if (this.connectionDrag.tempLine) {
        this.connectionDrag.tempLine.remove();
      }
      
      // Create new temporary line
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', startX);
      line.setAttribute('y1', startY);
      line.setAttribute('x2', endX);
      line.setAttribute('y2', endY);
      line.setAttribute('stroke', '#3b82f6');
      line.setAttribute('stroke-width', '3');
      line.setAttribute('stroke-dasharray', '5,5');
      line.setAttribute('opacity', '0.7');
      line.style.pointerEvents = 'none';
      
      this.connectionsSvg.appendChild(line);
      this.connectionDrag.tempLine = line;
    }

    updateConnectionDrag(event) {
      if (!this.connectionDrag.isDragging) return;
      
      const canvasRect = this.canvas.getBoundingClientRect();
      const currentX = event.clientX - canvasRect.left;
      const currentY = event.clientY - canvasRect.top;
      
      // Update temporary line position
      if (this.connectionDrag.tempLine) {
        this.connectionDrag.tempLine.setAttribute('x2', currentX);
        this.connectionDrag.tempLine.setAttribute('y2', currentY);
      }
      
      // Highlight input ports when hovering over them
      const elementUnderCursor = document.elementFromPoint(event.clientX, event.clientY);
      if (elementUnderCursor && elementUnderCursor.classList.contains('input-port')) {
        // Highlight potential target
        elementUnderCursor.style.background = '#10b981';
        elementUnderCursor.style.transform = 'scale(1.6)';
        elementUnderCursor.style.boxShadow = '0 0 15px rgba(16, 185, 129, 0.8)';
      }
    }

    completeConnectionDrag(event) {
      if (!this.connectionDrag.isDragging) return;
      
      // Find target port under cursor
      const elementUnderCursor = document.elementFromPoint(event.clientX, event.clientY);
      
      if (elementUnderCursor && elementUnderCursor.classList.contains('input-port')) {
        // Create connection
        const fromPort = `${this.connectionDrag.startPort.dataset.node}-${this.connectionDrag.startPort.dataset.port}`;
        const toPort = `${elementUnderCursor.dataset.node}-${elementUnderCursor.dataset.port}`;
        
        this.addConnection(fromPort, toPort);
      }
      
      // Clean up drag state
      this.endConnectionDrag();
    }

    endConnectionDrag() {
      // Remove temporary line
      if (this.connectionDrag.tempLine) {
        this.connectionDrag.tempLine.remove();
      }
      
      // Reset connection feedback
      this.hideConnectionFeedback();
      
      // Reset cursor
      document.body.style.cursor = '';
      
      // Reset drag state
      this.connectionDrag = {
        isDragging: false,
        startPort: null,
        tempLine: null,
        startX: 0,
        startY: 0
      };
    }

    // Enhanced port event handlers for both clicking and dragging
    setupEnhancedPortHandlers(port, nodeEl) {
      let clickTimeout = null;
      
      // Handle mousedown for potential drag start
      port.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        e.preventDefault();
        
        // Store click position for drag detection
        const startX = e.clientX;
        const startY = e.clientY;
        let hasDragged = false;
        
        // Set a timeout to detect click vs drag
        clickTimeout = setTimeout(() => {
          // If we haven't moved significantly, treat as click
          if (!hasDragged) {
            this.handlePortClick(port.dataset.port, port.dataset.node, port.classList.contains('output-port'));
          }
        }, 150); // 150ms delay to distinguish click from drag
        
        // Track mouse movement to detect drag
        const handleMouseMove = (moveEvent) => {
          const deltaX = Math.abs(moveEvent.clientX - startX);
          const deltaY = Math.abs(moveEvent.clientY - startY);
          
          // If moved more than 5px, start drag operation
          if (deltaX > 5 || deltaY > 5) {
            hasDragged = true;
            clearTimeout(clickTimeout);
            
            // Only start drag from output ports
            if (port.classList.contains('output-port')) {
              this.startConnectionDrag(port, moveEvent);
            }
            
            // Remove movement listener
            document.removeEventListener('mousemove', handleMouseMove);
          }
        };
        
        // Listen for mouse movement
        document.addEventListener('mousemove', handleMouseMove);
        
        // Clean up on mouse up
        const handleMouseUp = () => {
          clearTimeout(clickTimeout);
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        };
        
        document.addEventListener('mouseup', handleMouseUp);
      });
      
      // Keep existing hover effects
      port.addEventListener('mouseenter', (e) => {
        port.style.transform = 'scale(1.4)';
        port.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.4)';
        this.showTooltip(e, port.getAttribute('data-tooltip'));
      });
      
      port.addEventListener('mouseleave', (e) => {
        if (!this.connecting.from && !this.connectionDrag.isDragging) {
          port.style.transform = 'scale(1)';
          port.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.3)';
        }
        this.hideTooltip();
      });
    }

    // Canvas right-click functionality for node menu
    handleCanvasRightClick(event) {
      // Prevent default context menu
      event.preventDefault();
      
      // Only handle clicks on canvas background (not on nodes or connections)
      if (event.target !== this.canvas && event.target !== this.connectionsSvg) {
        return;
      }
      
      this.showNodeSelectionMenu(event);
    }

    showNodeSelectionMenu(event) {
      // Remove existing menu if present
      const existingMenu = document.getElementById('node-selection-menu');
      if (existingMenu) {
        existingMenu.remove();
      }
      
      // Calculate canvas center position
      const canvasRect = this.canvas.getBoundingClientRect();
      const centerX = canvasRect.width / 2;
      const centerY = canvasRect.height / 2;
      
      // Create menu element
      const menu = document.createElement('div');
      menu.id = 'node-selection-menu';
      menu.style.cssText = `
        position: absolute;
        left: ${centerX - 100}px;
        top: ${centerY - 150}px;
        width: 200px;
        max-height: 300px;
        background: white;
        border: 2px solid #3b82f6;
        border-radius: 8px;
        box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        z-index: 1000;
        overflow-y: auto;
        padding: 8px;
      `;
      
      // Add menu header
      menu.innerHTML = `
        <div style="padding: 8px; border-bottom: 1px solid #e5e7eb; font-weight: 600; color: #374151; text-align: center;">
          Select Node Type
        </div>
        <div style="max-height: 250px; overflow-y: auto;">
          ${this.generateNodeMenuItems()}
        </div>
      `;
      
      this.canvas.appendChild(menu);
      
      // Add click handlers to menu items
      menu.querySelectorAll('.menu-node-item').forEach(item => {
        item.addEventListener('click', (e) => {
          const nodeType = e.target.dataset.nodeType;
          this.handleMenuItemClick(nodeType);
        });
      });
      
      // Add click-away handler
      setTimeout(() => {
        document.addEventListener('click', this.handleMenuClickAway.bind(this), { once: true });
      }, 100);
    }

    generateNodeMenuItems() {
      let menuItems = '';
      
      // Iterate through all pages to collect all node types
      this.nodePages.forEach(page => {
        menuItems += `<div style="font-size: 12px; font-weight: 600; color: #6b7280; padding: 8px 4px 4px; border-top: 1px solid #f3f4f6;">${page.title}</div>`;
        
        page.nodes.forEach(node => {
          menuItems += `
            <div class="menu-node-item" data-node-type="${node.type}" style="
              padding: 6px 8px;
              cursor: pointer;
              border-radius: 4px;
              font-size: 14px;
              color: #374151;
              transition: background-color 0.2s;
            " onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">
              ${node.label}
            </div>
          `;
        });
      });
      
      return menuItems;
    }

    handleMenuItemClick(nodeType) {
      const canvasRect = this.canvas.getBoundingClientRect();
      const gridSize = 20;
      
      // Position at canvas center, snapped to grid
      const centerX = Math.round((canvasRect.width / 2) / gridSize) * gridSize;
      const centerY = Math.round((canvasRect.height / 2) / gridSize) * gridSize;
      
      const position = {
        x: centerX,
        y: centerY
      };
      
      // Create node at center position
      this.addNode(nodeType, position);
      
      // Remove menu
      const menu = document.getElementById('node-selection-menu');
      if (menu) {
        menu.remove();
      }
    }

    handleMenuClickAway(event) {
      const menu = document.getElementById('node-selection-menu');
      if (menu && !menu.contains(event.target)) {
        menu.remove();
      }
    }

    // Palette drag-and-drop functionality
    setupPaletteNodeDragDrop(button) {
      let dragStarted = false;
      
      button.addEventListener('mousedown', (e) => {
        e.preventDefault();
        
        const nodeType = button.dataset.nodeType;
        const startX = e.clientX;
        const startY = e.clientY;
        
        // Create a simple, fixed-size drag element
        const dragElement = document.createElement('div');
        dragElement.textContent = button.textContent;
        dragElement.style.cssText = `
          position: fixed;
          top: ${startY}px;
          left: ${startX}px;
          width: 80px;
          height: 32px;
          margin: 0;
          padding: 6px 12px;
          background: #3b82f6;
          color: white;
          border: 1px solid #2563eb;
          border-radius: 6px;
          font-size: 14px;
          font-family: system-ui, sans-serif;
          font-weight: 500;
          text-align: center;
          display: flex;
          align-items: center;
          justify-content: center;
          box-sizing: border-box;
          pointer-events: none;
          opacity: 0.8;
          transform: rotate(3deg);
          z-index: 10000;
          box-shadow: 0 5px 15px rgba(0,0,0,0.3);
          white-space: nowrap;
        `;
        
        document.body.appendChild(dragElement);
        
        this.nodeDrag = {
          isDragging: true,
          nodeType: nodeType,
          dragElement: dragElement,
          offsetX: 0,
          offsetY: 0
        };
        
        // Set cursor
        document.body.style.cursor = 'grabbing';
        
        // Handle mouse movement during drag
        const handleDragMove = (moveEvent) => {
          if (this.nodeDrag.isDragging) {
            dragStarted = true;
            this.nodeDrag.dragElement.style.left = moveEvent.clientX + 'px';
            this.nodeDrag.dragElement.style.top = moveEvent.clientY + 'px';
            
            // Highlight canvas when hovering over it
            const canvasRect = this.canvas.getBoundingClientRect();
            if (moveEvent.clientX >= canvasRect.left && 
                moveEvent.clientX <= canvasRect.right &&
                moveEvent.clientY >= canvasRect.top && 
                moveEvent.clientY <= canvasRect.bottom) {
              
              this.canvas.style.background = 'rgba(59, 130, 246, 0.1)';
              this.canvas.style.border = '2px dashed #3b82f6';
            } else {
              this.canvas.style.background = '';
              this.canvas.style.border = '';
            }
          }
        };
        
        // Handle mouse up - complete or cancel drag
        const handleDragEnd = (endEvent) => {
          if (dragStarted && this.nodeDrag.isDragging) {
            // Check if dropped on canvas
            const canvasRect = this.canvas.getBoundingClientRect();
            if (endEvent.clientX >= canvasRect.left && 
                endEvent.clientX <= canvasRect.right &&
                endEvent.clientY >= canvasRect.top && 
                endEvent.clientY <= canvasRect.bottom) {
              
              // Calculate position relative to canvas
              const gridSize = 20;
              const rawX = endEvent.clientX - canvasRect.left;
              const rawY = endEvent.clientY - canvasRect.top;
              
              const position = {
                x: Math.round(rawX / gridSize) * gridSize,
                y: Math.round(rawY / gridSize) * gridSize
              };
              
              // Constrain to canvas bounds
              position.x = Math.max(10, Math.min(position.x, canvasRect.width - 100));
              position.y = Math.max(10, Math.min(position.y, canvasRect.height - 50));
              
              // Create node at drop position
              this.addNode(this.nodeDrag.nodeType, position);
            }
          } else if (!dragStarted) {
            // Handle as regular click if no drag occurred
            this.handlePaletteButtonClick(button);
          }
          
          // Clean up
          this.endNodeDrag();
          document.removeEventListener('mousemove', handleDragMove);
          document.removeEventListener('mouseup', handleDragEnd);
        };
        
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);
      });
    }

    handlePaletteButtonClick(button) {
      const nodeType = button.dataset.nodeType;
      const rect = this.canvas.getBoundingClientRect();
      
      // Create position that snaps to grid (original behavior)
      const gridSize = 20;
      const rawX = Math.random() * (rect.width - 150) + 50;
      const rawY = Math.random() * (rect.height - 150) + 50;
      
      const position = {
        x: Math.round(rawX / gridSize) * gridSize,
        y: Math.round(rawY / gridSize) * gridSize
      };
      
      this.addNode(nodeType, position);
    }

    endNodeDrag() {
      if (this.nodeDrag.dragElement) {
        this.nodeDrag.dragElement.remove();
      }
      
      // Reset canvas styling
      this.canvas.style.background = '';
      this.canvas.style.border = '';
      
      // Reset cursor
      document.body.style.cursor = '';
      
      // Reset drag state
      this.nodeDrag = {
        isDragging: false,
        nodeType: null,
        dragElement: null,
        offsetX: 0,
        offsetY: 0
      };
    }

    selectNode(nodeId) {
      this.selectedNode = nodeId;
      document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
      document.getElementById(nodeId).classList.add('selected');
      this.openSidebar(nodeId);
    }

    deselectAll() {
      this.selectedNode = null;
      document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
      this.closeSidebar();
    }

    openSidebar(nodeId) {
      const node = this.nodes.get(nodeId);
      if (!node) return;

      document.getElementById('sidebar-title').textContent = `Edit ${node.type}`;
      
      let content = '';
      if (node.type === 'number') {
        content = `
          <div class="input-group">
            <label>Value:</label>
            <input type="number" id="node-value" value="${node.value || 0}" step="0.1">
          </div>
        `;
      } else if (node.type === 'componentInput') {
        content = `
          <div class="input-group">
            <label>Test Value:</label>
            <input type="number" id="node-value" value="${node.value || 0}" step="0.1">
          </div>
          <div class="input-group">
            <label>Input Name:</label>
            <input type="text" id="node-label" value="${node.label || 'Input'}" maxlength="20">
          </div>
          <p style="font-size: 12px; color: #666; margin-top: 10px;">
            This input will receive data from the main equation when the component is used.
          </p>
        `;
      } else if (node.type === 'variable') {
        const variableName = node.variable || 'x';
        const globalVar = this.globalVariables.get(variableName) || {value: '', isSet: false, inTable: false};
        
        content = `
          <div class="input-group">
            <label>Variable name:</label>
            <input type="text" id="node-variable" value="${variableName}" maxlength="5">
          </div>
          <div class="input-group">
            <label>Value (optional):</label>
            <input type="number" id="variable-value" value="${globalVar.value}" placeholder="Leave empty for symbolic">
          </div>
          <div class="input-group">
            <label>
              <input type="checkbox" id="variable-in-table" ${globalVar.inTable ? 'checked' : ''}>
              Show in variables table
            </label>
          </div>
          <p style="font-size: 12px; color: #666; margin-top: 10px;">
            Set a value to use this variable as a constant, or leave empty to keep it symbolic.
          </p>
        `;
      } else if (node.type === 'output') {
        const globalOutput = this.globalOutputs.get(nodeId) || {name: '', equation: '', result: '', inTable: false};
        
        content = `
          <div class="input-group">
            <label>Output Name:</label>
            <input type="text" id="output-name" value="${globalOutput.name || node.label || 'Output'}" maxlength="20">
          </div>
          <div class="input-group">
            <label>
              <input type="checkbox" id="output-in-table" ${globalOutput.inTable ? 'checked' : ''}>
              Show in equations table
            </label>
          </div>
          <p style="font-size: 12px; color: #666; margin-top: 10px;">
            This output will show the final output of connected calculations.<br>
            Check the box to include this equation in the equations table.
          </p>
        `;
      } else if (node.type === 'conditional') {
        // Initialize rules if they don't exist
        if (!node.rules) {
          node.rules = [
            { type: 'greater', value: 0, returnValue: 1, enabled: true, name: 'Rule 1' },
            { type: 'default', returnValue: 0, enabled: true, name: 'Default' }
          ];
        }

        content = `
          <div class="input-group">
            <label>Rules (evaluated in order):</label>
            <div id="rules-container" style="max-height: 300px; overflow-y: auto;">
              ${node.rules.map((rule, index) => `
                <div class="rule-item" data-rule-index="${index}" style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 4px; padding: 8px; margin: 4px 0;">
                  <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                    <input type="checkbox" data-rule-index="${index}" data-field="enabled" ${rule.enabled ? 'checked' : ''}>
                    <input type="text" data-rule-index="${index}" data-field="name" value="${rule.name || `Rule ${index + 1}`}" 
                           style="background: transparent; border: none; font-weight: 600; color: #475569; font-size: 12px; flex: 1;">
                    <button class="delete-rule-btn" data-rule-index="${index}" style="background: #ef4444; color: white; border: none; padding: 2px 6px; border-radius: 3px; font-size: 10px;">Delete</button>
                  </div>
                  
                  <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 4px;">
                    <span style="font-size: 11px;">If value is</span>
                    <select data-rule-index="${index}" data-field="type" style="flex: 1; padding: 2px; font-size: 11px;">
                      <option value="greater" ${rule.type === 'greater' ? 'selected' : ''}>greater than</option>
                      <option value="less" ${rule.type === 'less' ? 'selected' : ''}>less than</option>
                      <option value="equals" ${rule.type === 'equals' ? 'selected' : ''}>equals</option>
                      <option value="range" ${rule.type === 'range' ? 'selected' : ''}>in range</option>
                      <option value="negative" ${rule.type === 'negative' ? 'selected' : ''}>negative</option>
                      <option value="positive" ${rule.type === 'positive' ? 'selected' : ''}>positive</option>
                      <option value="zero" ${rule.type === 'zero' ? 'selected' : ''}>zero</option>
                      <option value="default" ${rule.type === 'default' ? 'selected' : ''}>default (catch-all)</option>
                    </select>
                  </div>
                  
                  ${rule.type !== 'negative' && rule.type !== 'positive' && rule.type !== 'zero' && rule.type !== 'default' ? `
                    <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 4px;">
                      <input type="number" data-rule-index="${index}" data-field="value" value="${rule.value || 0}" step="0.1" style="width: 60px; padding: 2px; font-size: 11px;">
                      ${rule.type === 'range' ? `
                        <span style="font-size: 11px;">to</span>
                        <input type="number" data-rule-index="${index}" data-field="maxValue" value="${rule.maxValue || 10}" step="0.1" style="width: 60px; padding: 2px; font-size: 11px;">
                      ` : ''}
                    </div>
                  ` : ''}
                  
                  <div style="display: flex; align-items: center; gap: 4px;">
                    <span style="font-size: 11px;">return</span>
                    <input type="number" data-rule-index="${index}" data-field="returnValue" value="${rule.returnValue || 0}" step="0.1" style="width: 60px; padding: 2px; font-size: 11px;">
                  </div>
                </div>
              `).join('')}
            </div>
            
            <div style="margin-top: 8px;">
              <button id="add-rule-btn" style="background: #10b981; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 4px;">+ Add Rule</button>
              <button id="add-preset-btn" style="background: #3b82f6; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">Presets</button>
            </div>
          </div>
        `;
      } else if (node.type === 'component') {
        const currentInputs = node.inputs || [];
        const currentOutputs = node.outputs || [];
        
        content = `
          <div class="input-group">
            <label>Component Name:</label>
            <input type="text" id="component-name" value="${node.customName || node.label || 'Component'}" maxlength="20" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; margin-top: 4px;">
          </div>
          
          
          
          <button id="edit-component-logic" style="background: #9333ea; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; width: 100%; margin-top: 12px;">Edit Component Logic</button>
        `;
      } else if (node.type === 'multiplexer') {
        const choiceCount = (node.inputs || []).length - 1; // Subtract 1 for selector input
        
        content = `
          <div class="input-group">
            <label>Number of Choices:</label>
            <input type="number" id="choice-count" value="${Math.max(2, choiceCount)}" min="2" max="10" style="width: 60px; padding: 4px; margin-top: 4px;">
            <p style="font-size: 12px; color: #666; margin-top: 8px;">
              The multiplexer selects one choice based on the selector value.<br>
              Choices are at the top, selector at the bottom.<br>
              Selector 0 = first choice, 1 = second choice, etc.
            </p>
          </div>
        `;
      } else if (node.type === 'splitter') {
        const outputCount = (node.outputs || []).length;
        
        content = `
          <div class="input-group">
            <label>Number of Outputs:</label>
            <input type="number" id="output-count" value="${Math.max(2, outputCount)}" min="2" max="10" style="width: 60px; padding: 4px; margin-top: 4px;">
            <p style="font-size: 12px; color: #666; margin-top: 8px;">
              The splitter copies the input value to all outputs.<br>
              Useful for sending one value to multiple calculation paths.
            </p>
          </div>
        `;
      }
      
      content += `
        <button class="delete-btn" id="delete-node-${nodeId}">Delete Node</button>
      `;
      
      document.getElementById('sidebar-content').innerHTML = content;
      
      // Add delete button event listener
      const deleteBtn = document.getElementById(`delete-node-${nodeId}`);
      if (deleteBtn) {
        deleteBtn.addEventListener('click', () => {
          this.deleteNode(nodeId);
        });
      }
      
      // Add event listeners for inputs
      const valueInput = document.getElementById('node-value');
      if (valueInput) {
        valueInput.addEventListener('input', (e) => {
          node.value = parseFloat(e.target.value) || 0;
          node.label = node.value.toString();
          document.querySelector(`#${nodeId} .node-content`).textContent = node.label;
          this.updateEquation();
        });
      }
      
      const variableInput = document.getElementById('node-variable');
      if (variableInput) {
        variableInput.addEventListener('input', (e) => {
          const oldVariable = node.variable || 'x';
          const newVariable = e.target.value || 'x';
          
          // Update the node
          node.variable = newVariable;
          node.label = newVariable;
          document.querySelector(`#${nodeId} .node-content`).textContent = node.label;
          
          // If variable name changed, update global variables map
          if (oldVariable !== newVariable) {
            const oldData = this.globalVariables.get(oldVariable);
            if (oldData) {
              this.globalVariables.delete(oldVariable);
              this.globalVariables.set(newVariable, oldData);
            }
          }
          
          this.updateEquation();
        });
      }

      const variableValueInput = document.getElementById('variable-value');
      if (variableValueInput) {
        variableValueInput.addEventListener('input', (e) => {
          const variableName = node.variable || 'x';
          const value = e.target.value;
          
          if (!this.globalVariables.has(variableName)) {
            this.globalVariables.set(variableName, {value: '', isSet: false, inTable: false});
          }
          
          const globalVar = this.globalVariables.get(variableName);
          globalVar.value = value;
          globalVar.isSet = value !== '';
          
          this.updateEquation();
        });
      }

      const variableTableCheckbox = document.getElementById('variable-in-table');
      if (variableTableCheckbox) {
        variableTableCheckbox.addEventListener('change', (e) => {
          const variableName = node.variable || 'x';
          
          if (!this.globalVariables.has(variableName)) {
            this.globalVariables.set(variableName, {value: '', isSet: false, inTable: false});
          }
          
          const globalVar = this.globalVariables.get(variableName);
          globalVar.inTable = e.target.checked;
          
          // Update table immediately if sidebar is open
          const tablesSidebar = document.getElementById('tables-sidebar');
          if (tablesSidebar && tablesSidebar.classList.contains('open')) {
            this.updateTables();
          }
        });
      }

      const outputNameInput = document.getElementById('output-name');
      if (outputNameInput) {
        outputNameInput.addEventListener('input', (e) => {
          const outputName = e.target.value || 'Output';
          
          if (!this.globalOutputs.has(nodeId)) {
            this.globalOutputs.set(nodeId, {name: '', equation: '', result: '', inTable: false});
          }
          
          const globalOutput = this.globalOutputs.get(nodeId);
          globalOutput.name = outputName;
          
          // Update node label
          node.label = outputName;
          document.querySelector(`#${nodeId} .node-content`).textContent = outputName;
        });
      }

      const outputTableCheckbox = document.getElementById('output-in-table');
      if (outputTableCheckbox) {
        outputTableCheckbox.addEventListener('change', (e) => {
          if (!this.globalOutputs.has(nodeId)) {
            this.globalOutputs.set(nodeId, {name: '', equation: '', latexEquation: '', result: '', inTable: false});
          }
          
          const globalOutput = this.globalOutputs.get(nodeId);
          globalOutput.inTable = e.target.checked;
          
          // Update table immediately if sidebar is open
          const tablesSidebar = document.getElementById('tables-sidebar');
          if (tablesSidebar && tablesSidebar.classList.contains('open')) {
            this.updateTables();
          }
        });
      }

      const labelInput = document.getElementById('node-label');
      if (labelInput) {
        labelInput.addEventListener('input', (e) => {
          node.label = e.target.value || 'Input';
          document.querySelector(`#${nodeId} .node-content`).textContent = node.label;
          this.updateEquation();
        });
      }

      // Rule Engine conditional node - dynamic rule management
      if (node.type === 'conditional') {
        // Add new rule
        document.getElementById('add-rule-btn')?.addEventListener('click', () => {
          if (!node.rules) node.rules = [];
          const ruleNumber = node.rules.length + 1;
          node.rules.push({ type: 'greater', value: 0, returnValue: 1, enabled: true, name: `Rule ${ruleNumber}` });
          this.openSidebar(nodeId); // Refresh sidebar
        });

        // Preset rules
        document.getElementById('add-preset-btn')?.addEventListener('click', () => {
          const presets = [
            'Positive/Negative/Zero Classification',
            'Range Categories (0-25, 26-50, 51-75, 76-100)',
            'Simple True/False (>0 = true, ≤0 = false)',
            'Grade Categories (A/B/C/D/F based on score)'
          ];
          
          const choice = prompt('Choose a preset:\n' + presets.map((p, i) => `${i+1}. ${p}`).join('\n'));
          const index = parseInt(choice) - 1;
          
          if (index >= 0 && index < presets.length) {
            switch(index) {
              case 0: // Positive/Negative/Zero
                node.rules = [
                  { type: 'positive', returnValue: 1, enabled: true, name: 'Positive' },
                  { type: 'negative', returnValue: -1, enabled: true, name: 'Negative' },
                  { type: 'zero', returnValue: 0, enabled: true, name: 'Zero' }
                ];
                break;
              case 1: // Range categories
                node.rules = [
                  { type: 'range', value: 0, maxValue: 25, returnValue: 1, enabled: true, name: 'Low (0-25)' },
                  { type: 'range', value: 26, maxValue: 50, returnValue: 2, enabled: true, name: 'Medium (26-50)' },
                  { type: 'range', value: 51, maxValue: 75, returnValue: 3, enabled: true, name: 'High (51-75)' },
                  { type: 'range', value: 76, maxValue: 100, returnValue: 4, enabled: true, name: 'Very High (76-100)' },
                  { type: 'default', returnValue: 0, enabled: true, name: 'Out of Range' }
                ];
                break;
              case 2: // True/False
                node.rules = [
                  { type: 'greater', value: 0, returnValue: 1, enabled: true, name: 'True (>0)' },
                  { type: 'default', returnValue: 0, enabled: true, name: 'False (≤0)' }
                ];
                break;
              case 3: // Grade categories
                node.rules = [
                  { type: 'greater', value: 89, returnValue: 4, enabled: true, name: 'A (90-100)' },
                  { type: 'greater', value: 79, returnValue: 3, enabled: true, name: 'B (80-89)' },
                  { type: 'greater', value: 69, returnValue: 2, enabled: true, name: 'C (70-79)' },
                  { type: 'greater', value: 59, returnValue: 1, enabled: true, name: 'D (60-69)' },
                  { type: 'default', returnValue: 0, enabled: true, name: 'F (<60)' }
                ];
                break;
            }
            this.openSidebar(nodeId); // Refresh sidebar
          }
        });

        // Handle rule changes
        document.querySelectorAll('[data-rule-index]').forEach(element => {
          const ruleIndex = parseInt(element.dataset.ruleIndex);
          const field = element.dataset.field;

          if (element.classList.contains('delete-rule-btn')) {
            element.addEventListener('click', () => {
              node.rules.splice(ruleIndex, 1);
              this.openSidebar(nodeId); // Refresh sidebar
            });
          } else {
            element.addEventListener('change', () => {
              if (!node.rules[ruleIndex]) return;
              
              if (field === 'enabled') {
                node.rules[ruleIndex].enabled = element.checked;
              } else if (field === 'type') {
                node.rules[ruleIndex].type = element.value;
                // Reset values when type changes
                if (element.value === 'range') {
                  node.rules[ruleIndex].maxValue = 10;
                }
                this.openSidebar(nodeId); // Refresh for dynamic fields
              } else if (field === 'name') {
                node.rules[ruleIndex].name = element.value;
              } else {
                const value = parseFloat(element.value) || 0;
                node.rules[ruleIndex][field] = value;
              }
              
              this.updateEquation(); // Update calculations
            });
          }
        });
      }

      // Component node controls
      if (node.type === 'component') {

        // Edit component logic button
        const editLogicBtn = document.getElementById('edit-component-logic');
        if (editLogicBtn) {
          editLogicBtn.addEventListener('click', () => {
            this.openComponentEditor(node.id);
          });
        }

        // Component name can be updated when saving
      }
      
      // Multiplexer node controls
      if (node.type === 'multiplexer') {
        const choiceCountInput = document.getElementById('choice-count');
        if (choiceCountInput) {
          choiceCountInput.addEventListener('change', () => {
            const count = parseInt(choiceCountInput.value) || 2;
            const clampedCount = Math.max(2, Math.min(10, count));
            
            // Update node configuration - choices at top, selector at bottom
            node.inputs = [];
            for (let i = 0; i < clampedCount; i++) {
              node.inputs.push(`choice${i}`);
            }
            node.inputs.push('selector');
            
            // Re-render node
            this.rerenderNode(node);
            this.updateEquation();
          });
        }
      }
      
      // Splitter node controls  
      if (node.type === 'splitter') {
        const outputCountInput = document.getElementById('output-count');
        if (outputCountInput) {
          outputCountInput.addEventListener('change', () => {
            const count = parseInt(outputCountInput.value) || 2;
            const clampedCount = Math.max(2, Math.min(10, count));
            
            // Update node configuration
            node.outputs = [];
            for (let i = 0; i < clampedCount; i++) {
              node.outputs.push(`output${i}`);
            }
            
            // Re-render node
            this.rerenderNode(node);
            this.updateEquation();
          });
        }
      }
      
      this.sidebar.classList.add('open');
    }

    closeSidebar() {
      this.sidebar.classList.remove('open');
    }

    rerenderNode(node) {
      // Remove existing node element
      const existingNode = document.getElementById(node.id);
      if (existingNode) {
        existingNode.remove();
      }
      
      // Re-render the node with updated configuration
      this.renderNode(node);
      
      // Update connections if any
      this.updateConnections();
    }

    // Removed redundant helper methods - use updateConnections() and updateEquation() directly

    deleteNode(nodeId) {
      // Remove node element
      const nodeEl = document.getElementById(nodeId);
      if (nodeEl) nodeEl.remove();
      
      // Remove from nodes map
      this.nodes.delete(nodeId);
      
      // Remove connections
      this.connections = this.connections.filter(conn => 
        !conn.from.startsWith(nodeId) && !conn.to.startsWith(nodeId)
      );
      
      // Handle component I/O nodes - update parent component ports
      const deletedNode = this.nodes.get(nodeId);
      if (deletedNode && deletedNode.componentIO && this.isEditingComponent) {
        this.updateParentComponentPorts();
      }
      
      this.updateConnections();
      this.updateEquation();
      this.closeSidebar();
    }

    // Dynamic Component Port Management
    updateComponentPortsInBackup(componentId) {
      if (!this.mainCanvasBackup || !this.mainCanvasBackup.nodes) return;
      
      const componentNode = this.mainCanvasBackup.nodes.get(componentId);
      if (!componentNode || componentNode.type !== 'component') return;
      
      // Scan current component data for I/O nodes
      const componentData = window.componentData[componentId];
      if (!componentData || !componentData.nodes) return;
      
      const inputNodes = [];
      const outputNodes = [];
      
      // Find all componentInput and componentOutput nodes
      for (const [, node] of componentData.nodes) {
        if (node.type === 'componentInput') {
          inputNodes.push({
            id: node.id,
            label: node.label || `Input${inputNodes.length + 1}`
          });
        } else if (node.type === 'componentOutput') {
          outputNodes.push({
            id: node.id,
            label: node.label || `Output${outputNodes.length + 1}`
          });
        }
      }
      
      // Update the component node's ports in the backup with simplified names
      componentNode.inputs = inputNodes.map((input, index) => `in${index + 1}`);
      componentNode.outputs = outputNodes.map((output, index) => `out${index + 1}`);
      
      // Store the mapping between port names and I/O node IDs for calculations
      componentData.portMapping = {
        inputs: {},
        outputs: {}
      };
      
      inputNodes.forEach((input, index) => {
        componentData.portMapping.inputs[`in${index + 1}`] = input.id;
      });
      
      outputNodes.forEach((output, index) => {
        console.log(`🔌 Mapping port out${index + 1} to ComponentOutput node:`, output.id, 'with label:', output.label);
        componentData.portMapping.outputs[`out${index + 1}`] = output.id;
      });
      
      console.log(`🔌 Updated component ${componentId} ports:`, {
        inputs: componentNode.inputs,
        outputs: componentNode.outputs,
        portMapping: componentData.portMapping
      });
    }
    
    updateParentComponentPorts() {
      if (!this.isEditingComponent || !this.currentComponentId) return;
      
      // Get the parent component node from the main canvas backup
      const parentComponentNode = this.mainCanvasBackup?.nodes?.get(this.currentComponentId);
      if (!parentComponentNode || parentComponentNode.type !== 'component') return;
      
      // Scan component data for input and output nodes
      const componentData = window.componentData[this.currentComponentId];
      if (!componentData || !componentData.nodes) return;
      
      const inputNodes = [];
      const outputNodes = [];
      
      // Find all componentInput and componentOutput nodes
      for (const [, node] of componentData.nodes) {
        if (node.type === 'componentInput') {
          inputNodes.push({
            id: node.id,
            label: node.label || `Input${inputNodes.length + 1}`
          });
        } else if (node.type === 'componentOutput') {
          outputNodes.push({
            id: node.id,
            label: node.label || `Output${outputNodes.length + 1}`
          });
        }
      }
      
      // Update the parent component's inputs and outputs with simplified names
      parentComponentNode.inputs = inputNodes.map((input, index) => `in${index + 1}`);
      parentComponentNode.outputs = outputNodes.map((output, index) => `out${index + 1}`);
      
      // Store the mapping between port names and I/O node IDs
      componentData.portMapping = {
        inputs: {},
        outputs: {}
      };
      
      inputNodes.forEach((input, index) => {
        componentData.portMapping.inputs[`in${index + 1}`] = input.id;
      });
      
      outputNodes.forEach((output, index) => {
        componentData.portMapping.outputs[`out${index + 1}`] = output.id;
      });
      
      // Re-render the component node with new ports
      this.rerenderComponentNode(this.currentComponentId);
    }
    
    getMainCanvasNode(nodeId) {
      // When editing component, access the backed up main canvas nodes
      if (this.mainCanvasBackup && this.mainCanvasBackup.nodes) {
        return this.mainCanvasBackup.nodes.get(nodeId);
      }
      // If not in component editing mode, use current nodes
      return this.nodes.get(nodeId);
    }
    
    rerenderComponentNode(nodeId) {
      // Update the component in the main canvas backup and re-render it if we're editing components
      if (this.mainCanvasBackup && this.mainCanvasBackup.nodes.has(nodeId)) {
        const componentNode = this.mainCanvasBackup.nodes.get(nodeId);
        
        // Find the existing component element in the DOM and update it
        const existingElement = document.getElementById(nodeId);
        if (existingElement) {
          // Remove old element and create new one with updated ports
          existingElement.remove();
          this.renderNode(componentNode);
          console.log(`📝 Component ${nodeId} visually updated with new ports`);
        } else {
          console.log(`📝 Component ${nodeId} ports updated - will reflect when returning to main canvas`);
        }
      }
    }
    
    calculateComponentResult(componentNodeId, requestedPortId) {
      console.log('🧮 calculateComponentResult called:', { componentNodeId, requestedPortId });
      
      // Get component data and port mapping
      console.log('🔍 Available component data keys:', Object.keys(window.componentData || {}));
      console.log('🎯 Looking for component ID:', componentNodeId);
      
      // First try direct lookup
      let componentData = window.componentData[componentNodeId];
      let actualComponentId = componentNodeId;
      
      // If not found, search for any component node that might be connected to this calculation
      if (!componentData) {
        console.log('🔄 Direct lookup failed, searching for connected component...');
        
        // Find the actual component node by checking all available component data
        for (const [availableId, data] of Object.entries(window.componentData || {})) {
          const node = this.nodes.get(availableId);
          if (node && node.type === 'component') {
            console.log('🎯 Found component node:', availableId);
            componentData = data;
            actualComponentId = availableId;
            break;
          }
        }
      }
      
      console.log('📊 Component data:', componentData);
      
      if (!componentData || !componentData.portMapping) {
        console.log('❌ No component data or port mapping for:', actualComponentId);
        return '?';
      }
      
      console.log('🔌 Port mapping:', componentData.portMapping);
      
      // Map the requested port ID to the corresponding component output node
      let actualOutputPort = requestedPortId;
      let outputNodeId = componentData.portMapping.outputs[requestedPortId];
      
      if (!outputNodeId) {
        console.log('🔄 Port ID translation needed - searching for connected output port...');
        
        // If the requestedPortId doesn't directly map, try to find it by matching connection
        // This handles cases where the external connection format differs from internal port names
        const outputPorts = Object.keys(componentData.portMapping.outputs);
        console.log('🎯 Available output ports:', outputPorts);
        
        // For single output, use it
        if (outputPorts.length === 1) {
          actualOutputPort = outputPorts[0];
          outputNodeId = componentData.portMapping.outputs[actualOutputPort];
          console.log('✅ Using single output port:', actualOutputPort, '→', outputNodeId);
        } else {
          // For multiple outputs, try to match the requested port ID format
          // Look for exact match first, then fall back to first available
          const matchingPort = outputPorts.find(port => 
            requestedPortId.includes(port) || port.includes(requestedPortId)
          );
          
          if (matchingPort) {
            actualOutputPort = matchingPort;
            outputNodeId = componentData.portMapping.outputs[actualOutputPort];
            console.log('✅ Found matching output port:', actualOutputPort, '→', outputNodeId);
          } else {
            actualOutputPort = outputPorts[0];
            outputNodeId = componentData.portMapping.outputs[actualOutputPort];
            console.log('⚠️ No exact match, using first output port:', actualOutputPort, '→', outputNodeId);
          }
        }
      } else {
        console.log('✅ Direct port mapping found:', actualOutputPort, '→', outputNodeId);
        console.log('🔍 Port mapping details:', componentData.portMapping.outputs);
      }
      
      console.log('🎯 Final output node ID for port', actualOutputPort, ':', outputNodeId);
      
      if (!outputNodeId) {
        console.log('❌ No output node found for port:', actualOutputPort);
        return '?';
      }
      
      // Set up input values from connections to the component (use actual component ID)
      this.setupComponentInputs(actualComponentId, componentData);
      
      // Calculate the result from the componentOutput node in the component's context
      const result = this.calculateComponentNodeResult(outputNodeId, componentData, actualComponentId);
      console.log('✅ Component calculation result:', result);
      return result;
    }
    
    setupComponentInputs(componentNodeId, componentData) {
      console.log('🔧 setupComponentInputs called for:', componentNodeId);
      console.log('🔧 Available main canvas connections:', this.connections.length);
      
      // Find all connections to this component's input ports
      const componentInputs = componentData.portMapping.inputs;
      console.log('🔧 Component input ports:', componentInputs);
      
      for (const [portName, inputNodeId] of Object.entries(componentInputs)) {
        console.log(`🔧 Processing input port ${portName} → ${inputNodeId}`);
        
        // Find connection to this input port
        const targetConnection = `${componentNodeId}-${portName}`;
        console.log('🔧 Looking for connection to:', targetConnection);
        
        const connection = this.connections.find(conn => 
          conn.to === targetConnection
        );
        
        console.log('🔧 Found connection:', connection);
        
        if (connection) {
          // Extract source info and calculate input value
          // Parse connection format: "node-ID-timestamp-port"
          const connectionParts = connection.from.split('-');
          const sourcePortId = connectionParts[connectionParts.length - 1]; // Last part is port
          const sourceNodeId = connectionParts.slice(0, -1).join('-'); // Everything before last part is node ID
          console.log('🔧 Parsed connection:', { sourceNodeId, sourcePortId });
          
          // Get the external source node directly (don't use calculateResult for external nodes)
          const externalSourceNode = this.getMainCanvasNode(sourceNodeId);
          console.log('🔧 External source node:', externalSourceNode);
          console.log('🔧 MainCanvasBackup exists:', !!this.mainCanvasBackup);
          if (this.mainCanvasBackup && this.mainCanvasBackup.nodes) {
            console.log('🔧 Available backup node IDs:', Array.from(this.mainCanvasBackup.nodes.keys()));
          }
          console.log('🔧 Looking for node ID:', sourceNodeId);
          
          let inputValue = '?';
          if (externalSourceNode) {
            switch (externalSourceNode.type) {
              case 'number':
                inputValue = parseFloat(externalSourceNode.value) || 0;
                break;
              case 'variable': {
                const variableName = externalSourceNode.variable || 'x';
                const globalVar = this.globalVariables.get(variableName);
                if (globalVar && globalVar.isSet) {
                  inputValue = parseFloat(globalVar.value) || 0;
                } else {
                  inputValue = NaN; // Variable not set
                }
                break;
              }
              case 'component':
                inputValue = this.calculateComponentResult(sourceNodeId, sourcePortId);
                break;
              default:
                inputValue = this.calculateResult(sourceNodeId, sourcePortId);
            }
          }
          
          console.log('🔧 Calculated input value:', inputValue);
          
          // Set the input value on the componentInput node
          const inputNode = componentData.nodes.get(inputNodeId);
          if (inputNode) {
            inputNode.value = inputValue;
            console.log('🔧 Set input node value:', inputNode.value);
          } else {
            console.log('🔧 ❌ Input node not found:', inputNodeId);
          }
        } else {
          console.log('🔧 ❌ No connection found for port:', portName);
        }
      }
    }
    
    calculateComponentNodeResult(nodeId, componentData, actualComponentId) {
      console.log('🎯 calculateComponentNodeResult called for:', nodeId);
      
      // Use the component's internal nodes and connections for calculation
      const node = componentData.nodes.get(nodeId);
      console.log('📦 Node found:', node);
      
      if (!node) {
        console.log('❌ Node not found in component data');
        return '?';
      }
      
      // For componentOutput nodes, get the connected input value
      if (node.type === 'componentOutput') {
        console.log('🔍 Processing componentOutput node');
        
        // BULLETPROOF APPROACH: For simple components with one input and one output,
        // directly use the input value without relying on connection lookup
        const inputNodes = Array.from(componentData.nodes.values()).filter(n => n.type === 'componentInput');
        const outputNodes = Array.from(componentData.nodes.values()).filter(n => n.type === 'componentOutput');
        
        console.log('🔍 Component structure:', { 
          inputs: inputNodes.length, 
          outputs: outputNodes.length,
          totalNodes: componentData.nodes.size 
        });
        
        console.log('🔍 Checking simple pass-through condition:', { inputCount: inputNodes.length, outputCount: outputNodes.length });
        
        if (inputNodes.length === 1 && outputNodes.length === 1) {
          // Enhanced component calculation: get external input and process through internal logic
          console.log('🧮 Processing component with internal calculation');
          const inputNode = inputNodes[0];
          const outputNode = outputNodes[0];
          
          // Get the external input value
          const inputPortName = Object.keys(componentData.portMapping.inputs)[0]; // Should be 'in1'
          const targetPortId = `${actualComponentId}-${inputPortName}`;
          
          const connections = this.connections || [];
          const externalConnection = connections.find(conn => conn.to === targetPortId);
          
          let externalInputValue = 0; // Default value
          if (externalConnection) {
            const connectionParts = externalConnection.from.split('-');
            const sourcePortId = connectionParts.pop();
            const sourceNodeId = connectionParts.join('-');
            const mainNodes = this.nodes || new Map();
            const mainConnections = this.connections || [];
            const calculatedValue = this.calculateMainCanvasResult(sourceNodeId, sourcePortId, mainNodes, mainConnections);
            if (calculatedValue !== '?') {
              externalInputValue = calculatedValue;
            }
          }
          
          console.log('🔢 External input value:', externalInputValue);
          
          // Set the input value on the componentInput node
          inputNode.value = externalInputValue;
          
          // Now calculate through the component's internal structure to the output
          console.log('🔗 Calculating through internal component structure...');
          const internalResult = this.calculateComponentInternalResult(outputNode.id, 'in', componentData);
          console.log('✅ Internal calculation result:', internalResult);
          
          return internalResult !== '?' ? internalResult : externalInputValue;
        }
        
        // If not a simple case, try connection-based calculation
        const targetConnectionId = `${nodeId}-in`;
        console.log('🔗 Looking for connection to:', targetConnectionId);
        console.log('📋 Available connections:', componentData.connections);
        
        const connection = componentData.connections.find(conn =>
          conn.to === targetConnectionId
        );
        console.log('🎯 Found connection:', connection);
        
        if (connection) {
          // Parse connection format: "node-ID-timestamp-port"
          const connectionParts = connection.from.split('-');
          const portId = connectionParts[connectionParts.length - 1]; // Last part is port
          const sourceNodeId = connectionParts.slice(0, -1).join('-'); // Everything before last part is node ID
          console.log('⚡ Calculating from source:', { sourceNodeId, portId });
          
          // Recursively calculate using component's internal nodes
          const result = this.calculateComponentInternalResult(sourceNodeId, portId, componentData);
          console.log('✅ Internal calculation result:', result);
          return result;
        } else {
          console.log('❌ No connection found, trying fallback approach');
          
          // FALLBACK: If there's a componentInput, use its value
          if (inputNodes.length > 0) {
            const fallbackValue = inputNodes[0].value || 0;
            console.log('🔄 Using fallback input value:', fallbackValue);
            return fallbackValue;
          }
        }
      }
      
      console.log('❌ Node type not handled or no connection found');
      return '?';
    }
    
    calculateMainCanvasResult(nodeId, portId, nodes, connections) {
      const node = nodes.get(nodeId);
      if (!node) return '?';
      
      switch (node.type) {
        case 'number':
          return node.value || 0;
          
        case 'add': {
          const left = this.getMainCanvasInput(nodeId, 'in1', nodes, connections);
          const right = this.getMainCanvasInput(nodeId, 'in2', nodes, connections);
          if (left === '?' || right === '?') return '?';
          return left + right;
        }
        
        case 'subtract': {
          const left = this.getMainCanvasInput(nodeId, 'in1', nodes, connections);
          const right = this.getMainCanvasInput(nodeId, 'in2', nodes, connections);
          if (left === '?' || right === '?') return '?';
          return left - right;
        }
        
        case 'multiply': {
          const left = this.getMainCanvasInput(nodeId, 'in1', nodes, connections);
          const right = this.getMainCanvasInput(nodeId, 'in2', nodes, connections);
          if (left === '?' || right === '?') return '?';
          return left * right;
        }
        
        case 'divide': {
          const left = this.getMainCanvasInput(nodeId, 'in1', nodes, connections);
          const right = this.getMainCanvasInput(nodeId, 'in2', nodes, connections);
          if (left === '?' || right === '?' || right === 0) return '?';
          return left / right;
        }
        
        // Mathematical constants
        case 'constant_pi':
          return Math.PI; // π ≈ 3.14159
        case 'constant_e':
          return Math.E; // e ≈ 2.71828
        case 'constant_phi':
          return (1 + Math.sqrt(5)) / 2; // φ (golden ratio) ≈ 1.618
        case 'constant_sqrt2':
          return Math.sqrt(2); // √2 ≈ 1.414

        case 'variable': {
          const variableName = node.variable || 'x';
          if (this.globalVariables && this.globalVariables.has(variableName)) {
            const globalVar = this.globalVariables.get(variableName);
            if (globalVar && globalVar.isSet) {
              const value = parseFloat(globalVar.value);
              return isNaN(value) ? '?' : value;
            }
          }
          return '?';
        }
        
        default:
          return node.value || 0;
      }
    }
    
    getMainCanvasInput(nodeId, portId, nodes, connections) {
      const targetConnectionId = `${nodeId}-${portId}`;
      const connection = connections.find(conn => conn.to === targetConnectionId);
      
      if (connection) {
        // Parse connection.from which is like "node-2-1760587322032-out"
        const fromParts = connection.from.split('-');
        const sourcePortId = fromParts.pop(); // "out"
        const sourceNodeId = fromParts.join('-'); // "node-2-1760587322032"
        return this.calculateMainCanvasResult(sourceNodeId, sourcePortId, nodes, connections);
      }
      
      return '?';
    }
    
    calculateComponentInternalResult(nodeId, portId, componentData) {
      const node = componentData.nodes.get(nodeId);
      if (!node) return '?';
      
      // Debug: calculateComponentInternalResult for node
      
      // Handle different node types within the component
      switch (node.type) {
        case 'componentInput':
          // Return the value that was set externally 
          console.log('📥 ComponentInput returning:', node.value);
          return node.value || 0;
          
        case 'componentOutput': {
          // For componentOutput, get the value from its input connection
          console.log('📤 ComponentOutput - looking for input connection');
          const inputValue = this.getComponentNodeInput(nodeId, 'in', componentData);
          console.log('📤 ComponentOutput input value:', inputValue);
          return inputValue;
        }
          
        case 'number':
          console.log('🔢 Number node value:', node.value, 'from node:', node.id);
          return node.value || 0;
          
        case 'add': {
          console.log('➕ Add operation');
          const left = this.getComponentNodeInput(nodeId, 'in1', componentData);
          const right = this.getComponentNodeInput(nodeId, 'in2', componentData);
          console.log('➕ Add inputs:', left, '+', right);
          if (left === '?' || right === '?') return '?';
          const result = left + right;
          console.log('➕ Add result:', result);
          return result;
        }
        
        case 'subtract': {
          console.log('➖ Subtract operation');
          const left = this.getComponentNodeInput(nodeId, 'in1', componentData);
          const right = this.getComponentNodeInput(nodeId, 'in2', componentData);
          console.log('➖ Subtract inputs:', left, '-', right);
          if (left === '?' || right === '?') return '?';
          const result = left - right;
          console.log('➖ Subtract result:', result);
          return result;
        }
        
        case 'multiply': {
          console.log('✖️ Multiply operation');
          const left = this.getComponentNodeInput(nodeId, 'in1', componentData);
          const right = this.getComponentNodeInput(nodeId, 'in2', componentData);
          console.log('✖️ Multiply inputs:', left, '×', right);
          if (left === '?' || right === '?') return '?';
          const result = left * right;
          console.log('✖️ Multiply result:', result);
          return result;
        }
        
        case 'divide': {
          console.log('➗ Divide operation');
          const left = this.getComponentNodeInput(nodeId, 'in1', componentData);
          const right = this.getComponentNodeInput(nodeId, 'in2', componentData);
          console.log('➗ Divide inputs:', left, '÷', right);
          if (left === '?' || right === '?' || right === 0) return '?';
          const result = left / right;
          console.log('➗ Divide result:', result);
          return result;
        }
        
        case 'power': {
          console.log('🔺 Power operation');
          const base = this.getComponentNodeInput(nodeId, 'base', componentData);
          const exp = this.getComponentNodeInput(nodeId, 'exp', componentData);
          console.log('🔺 Power inputs:', base, '^', exp);
          if (base === '?' || exp === '?') return '?';
          const result = Math.pow(base, exp);
          console.log('🔺 Power result:', result);
          return result;
        }
        
        // Advanced math operations
        case 'sqrt': {
          const value = this.getComponentNodeInput(nodeId, 'value', componentData);
          const root = this.getComponentNodeInput(nodeId, 'root', componentData);
          const rootValue = (root === '?' || root === null) ? 2 : root;
          if (value === '?' || value < 0) return '?';
          return Math.pow(value, 1 / rootValue);
        }
        
        case 'sin': {
          const input = this.getComponentNodeInput(nodeId, 'in', componentData);
          if (input === '?') return '?';
          return Math.sin(input);
        }
        
        case 'cos': {
          const input = this.getComponentNodeInput(nodeId, 'in', componentData);
          if (input === '?') return '?';
          return Math.cos(input);
        }
        
        case 'tan': {
          const input = this.getComponentNodeInput(nodeId, 'in', componentData);
          if (input === '?') return '?';
          return Math.tan(input);
        }
        
        // Mathematical constants
        case 'constant_pi':
          return Math.PI; // π ≈ 3.14159
        case 'constant_e':
          return Math.E; // e ≈ 2.71828
        case 'constant_phi':
          return (1 + Math.sqrt(5)) / 2; // φ (golden ratio) ≈ 1.618
        case 'constant_sqrt2':
          return Math.sqrt(2); // √2 ≈ 1.414

        case 'variable': {
          console.log('🔤 Variable node in component:', node.variable);
          const variableName = node.variable || 'x';
          
          // Access global variable system from main canvas
          if (this.globalVariables && this.globalVariables.has(variableName)) {
            const globalVar = this.globalVariables.get(variableName);
            if (globalVar && globalVar.isSet) {
              const value = parseFloat(globalVar.value);
              console.log('🔤 Variable', variableName, 'resolved to:', value);
              return isNaN(value) ? '?' : value;
            }
          }
          
          console.log('🔤 Variable', variableName, 'not set globally, returning ?');
          return '?';
        }
        
        default:
          console.log('❓ Unknown node type in component:', node.type);
          return node.value || '?';
      }
    }
    
    getComponentNodeInput(nodeId, portId, componentData) {
      const targetConnectionId = `${nodeId}-${portId}`;
      const connection = componentData.connections.find(conn =>
        conn.to === targetConnectionId
      );
      
      if (connection) {
        // Parse connection.from which is like "node-2-1760587322032-out"
        const fromParts = connection.from.split('-');
        const sourcePortId = fromParts.pop(); // "out"
        const sourceNodeId = fromParts.join('-'); // "node-2-1760587322032"
        
        console.log('🔗 getComponentNodeInput found connection:', {
          target: targetConnectionId,
          source: sourceNodeId,
          sourcePort: sourcePortId
        });
        
        return this.calculateComponentInternalResult(sourceNodeId, sourcePortId, componentData);
      }
      
      console.log('❌ No connection found for:', targetConnectionId);
      return '?';
    }
    
    buildComponentEquation(componentNodeId, requestedPortId) {
      // Get component data and port mapping
      const componentData = window.componentData[componentNodeId];
      if (!componentData || !componentData.portMapping) {
        return 'Component()';
      }
      
      // Find which componentOutput node corresponds to the requested port
      const outputNodeId = componentData.portMapping.outputs[requestedPortId];
      if (!outputNodeId) {
        return 'Component()';
      }
      
      // Build equation from the componentOutput node in the component's context
      return this.buildComponentInternalEquation(outputNodeId, componentData) || 'Component()';
    }
    
    buildComponentInternalEquation(nodeId, componentData) {
      const node = componentData.nodes.get(nodeId);
      if (!node) return 'Component()';
      
      // For componentOutput nodes, get the connected input equation
      if (node.type === 'componentOutput') {
        const connection = componentData.connections.find(conn =>
          conn.to === `${nodeId}-in`
        );
        
        if (connection) {
          // Parse connection format: "node-ID-timestamp-port"
          const connectionParts = connection.from.split('-');
          const sourceNodeId = connectionParts.slice(0, -1).join('-'); // Everything before last part is node ID
          return this.buildComponentInternalEquation(sourceNodeId, componentData);
        }
      }
      
      // Handle different node types within the component
      switch (node.type) {
        case 'componentInput':
          return node.label || 'Input';
          
        case 'number':
          return node.value?.toString() || '0';
          
        case 'add': {
          const left = this.getComponentNodeEquation(nodeId, 'in1', componentData);
          const right = this.getComponentNodeEquation(nodeId, 'in2', componentData);
          if (!left || !right) return '';
          return `(${left} + ${right})`;
        }
        
        case 'multiply': {
          const left = this.getComponentNodeEquation(nodeId, 'in1', componentData);
          const right = this.getComponentNodeEquation(nodeId, 'in2', componentData);
          if (!left || !right) return '';
          return `(${left} × ${right})`;
        }
        
        default:
          return node.label || node.type;
      }
    }
    
    getComponentNodeEquation(nodeId, portId, componentData) {
      const connection = componentData.connections.find(conn =>
        conn.to === `${nodeId}-${portId}`
      );
      
      if (connection) {
        // Parse connection format: "node-ID-timestamp-port"
        const connectionParts = connection.from.split('-');
        const sourceNodeId = connectionParts.slice(0, -1).join('-'); // Everything before last part is node ID
        return this.buildComponentInternalEquation(sourceNodeId, componentData);
      }
      
      return '';
    }

    updateConnections() {
      this.connectionsSvg.innerHTML = '';
      
      if (this.connections.length === 0) {
        return;
      }
      
      this.connections.forEach((conn, index) => {
        // Parse connection IDs properly (e.g., "node-1-1734454973667-out" -> nodeId="node-1-1734454973667", portId="out")
        const fromParts = conn.from.split('-');
        const fromPortId = fromParts.pop();
        const fromNodeId = fromParts.join('-');
        
        const toParts = conn.to.split('-');
        const toPortId = toParts.pop();
        const toNodeId = toParts.join('-');
        
        const fromEl = document.querySelector(`#${fromNodeId} [data-port="${fromPortId}"]`);
        const toEl = document.querySelector(`#${toNodeId} [data-port="${toPortId}"]`);
        
        if (fromEl && toEl) {
          const fromRect = fromEl.getBoundingClientRect();
          const toRect = toEl.getBoundingClientRect();
          const canvasRect = this.canvas.getBoundingClientRect();
          
          // Calculate port positions relative to canvas
          const fromPos = {
            x: fromRect.left - canvasRect.left + fromRect.width / 2,
            y: fromRect.top - canvasRect.top + fromRect.height / 2
          };
          
          const toPos = {
            x: toRect.left - canvasRect.left + toRect.width / 2,
            y: toRect.top - canvasRect.top + toRect.height / 2
          };
          
          // Create beautiful S-shaped curve using cubic bezier
          const dx = toPos.x - fromPos.x;
          const controlOffset = Math.abs(dx) * 0.5 + 50; // Dynamic curve based on distance
          
          const control1 = {
            x: fromPos.x + controlOffset,
            y: fromPos.y
          };
          
          const control2 = {
            x: toPos.x - controlOffset,
            y: toPos.y
          };
          
          // Create SVG group for connection (path + arrowhead)
          const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          group.classList.add('connection-group');
          group.style.pointerEvents = 'auto';
          group.style.opacity = '1';
          group.style.visibility = 'visible';
          group.style.zIndex = '10';
          
          // Main connection path (S-curve)
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          const d = `M ${fromPos.x} ${fromPos.y} C ${control1.x} ${control1.y} ${control2.x} ${control2.y} ${toPos.x} ${toPos.y}`;
          
          path.setAttribute('d', d);
          path.setAttribute('stroke', '#3b82f6');
          path.setAttribute('stroke-width', '3');
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke-linecap', 'round');
          path.setAttribute('opacity', '1');
          path.style.cursor = 'pointer';
          path.style.visibility = 'visible';
          path.style.display = 'block';
          path.style.filter = 'drop-shadow(0 2px 4px rgba(0,0,0,0.1))';
          
          // Arrowhead marker
          const arrowhead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
          const arrowSize = 8;
          const angle = Math.atan2(toPos.y - control2.y, toPos.x - control2.x);
          
          const arrowPoints = [
            { x: toPos.x, y: toPos.y },
            { 
              x: toPos.x - arrowSize * Math.cos(angle - Math.PI / 6), 
              y: toPos.y - arrowSize * Math.sin(angle - Math.PI / 6) 
            },
            { 
              x: toPos.x - arrowSize * Math.cos(angle + Math.PI / 6), 
              y: toPos.y - arrowSize * Math.sin(angle + Math.PI / 6) 
            }
          ];
          
          arrowhead.setAttribute('points', arrowPoints.map(p => `${p.x},${p.y}`).join(' '));
          arrowhead.setAttribute('fill', '#3b82f6');
          arrowhead.setAttribute('opacity', '1');
          arrowhead.style.visibility = 'visible';
          arrowhead.style.display = 'block';
          arrowhead.style.filter = 'drop-shadow(0 1px 2px rgba(0,0,0,0.1))';
          
          // Add hover effects
          group.addEventListener('mouseenter', () => {
            path.setAttribute('stroke', '#1d4ed8');
            path.setAttribute('stroke-width', '4');
            arrowhead.setAttribute('fill', '#1d4ed8');
          });
          
          group.addEventListener('mouseleave', () => {
            path.setAttribute('stroke', '#3b82f6');
            path.setAttribute('stroke-width', '3');
            arrowhead.setAttribute('fill', '#3b82f6');
          });
          
          // Add click to delete connection
          group.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm('Delete this connection?')) {
              this.connections = this.connections.filter(c => c.id !== conn.id);
              this.updateConnections();
              this.updateEquation();
            }
          });
          
          group.appendChild(path);
          group.appendChild(arrowhead);
          this.connectionsSvg.appendChild(group);
          
          // SVG connection rendered successfully
          
        } else {
          console.warn('Could not find elements for connection:', conn.from, '→', conn.to);
        }
      });
    }

    updateEquation() {
      // Find ALL output/display nodes, not just the first one
      const outputNodes = Array.from(this.nodes.values()).filter(node => node.type === 'output');
      if (outputNodes.length === 0) {
        this.equationDisplay.textContent = 'Add an Output node to see the equation...';
        this.equationDisplay.style.color = '#9ca3af';
        return;
      }

      // Update each output node individually
      outputNodes.forEach(outputNode => {
        const equation = this.buildEquation(outputNode.id, 'in');
        const latexEquation = this.buildLatexEquation(outputNode.id, 'in');
        const result = this.calculateResult(outputNode.id, 'in');
        
        // Store in global outputs for table display
        if (!this.globalOutputs.has(outputNode.id)) {
          this.globalOutputs.set(outputNode.id, {
            name: outputNode.label || 'Output',
            equation: '',
            latexEquation: '',
            result: '',
            inTable: false
          });
        }
        
        const globalOutput = this.globalOutputs.get(outputNode.id);
        globalOutput.equation = equation || '';
        globalOutput.latexEquation = latexEquation || '';
        
        // Show equation instead of NaN/undefined for non-numeric results
        if (result === null || result === undefined || isNaN(result)) {
          globalOutput.result = equation || 'undefined';
        } else {
          globalOutput.result = result.toString();
        }
        
        // Update the Output node itself to show the computed value
        const outputNodeEl = document.getElementById(outputNode.id);
        if (outputNodeEl) {
          const contentEl = outputNodeEl.querySelector('.node-content');
          if (contentEl) {
            if (equation) {
              // Show equation instead of NaN for non-numeric results
              const displayResult = (result === null || result === undefined || isNaN(result)) ? 
                equation : result;
              contentEl.textContent = `Output: ${displayResult}`;
            } else {
              contentEl.textContent = globalOutput.name || 'Output';
            }
          }
          
          // Add click listener to make this output's equation the main display
          outputNodeEl.addEventListener('click', () => {
            this.setMainEquationDisplay(outputNode.id, equation, result);
          });
        }
      });

      // Update tables if sidebar is visible
      const tablesSidebar = document.getElementById('tables-sidebar');
      if (tablesSidebar && tablesSidebar.classList.contains('open')) {
        this.updateTables();
      }

      // Update the main equation display with the first output node (for backward compatibility)
      const firstOutputNode = outputNodes[0];
      const equation = this.buildEquation(firstOutputNode.id, 'in');
      const result = this.calculateResult(firstOutputNode.id, 'in');
      
      if (equation) {
        // Show equation instead of NaN for non-numeric results
        const displayResult = (result === null || result === undefined || isNaN(result)) ? 
          equation : result;
        this.equationDisplay.textContent = `${equation} = ${displayResult}`;
        this.equationDisplay.style.color = '#1e293b';
      } else {
        this.equationDisplay.textContent = 'Connect nodes to the Output to generate equation...';
        this.equationDisplay.style.color = '#9ca3af';
      }

      // Legacy code for resetting display - moved into forEach above
      if (!equation) {
        const outputNodeEl = document.getElementById(firstOutputNode.id);
        if (outputNodeEl) {
          const contentEl = outputNodeEl.querySelector('.node-content');
          if (contentEl) {
            contentEl.textContent = 'Result';
          }
        }
      }
    }
    
    calculateResult(nodeId, portId) {
      console.log('🔍 calculateResult called:', { nodeId, portId });
      const connection = this.connections.find(conn => conn.to === `${nodeId}-${portId}`);
      console.log('🔍 Found connection:', connection);
      if (!connection) {
        console.log('🔍 No connection found, returning ?');
        return '?';
      }

      const parts = connection.from.split('-');
      parts.pop(); // Remove port id
      const sourceNodeId = parts.join('-');
      console.log('🔍 Looking for source node:', sourceNodeId);
      const sourceNode = this.getMainCanvasNode(sourceNodeId);
      console.log('🔍 Found source node:', sourceNode);
      if (!sourceNode) {
        console.log('🔍 Source node not found, returning ?');
        return '?';
      }

      switch (sourceNode.type) {
        // Generators
        case 'number':
          return parseFloat(sourceNode.value) || 0;
        case 'variable': {
          const variableName = sourceNode.variable || 'x';
          const globalVar = this.globalVariables.get(variableName);
          if (globalVar && globalVar.isSet) {
            return parseFloat(globalVar.value) || 0;
          }
          return NaN; // Variable not set
        }
        case 'constant_pi':
          return Math.PI;
        case 'constant_e':
          return Math.E;
        case 'constant_phi':
          return (1 + Math.sqrt(5)) / 2; // Golden ratio
        case 'constant_sqrt2':
          return Math.sqrt(2);
          
        // Basic Operators
        case 'add': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left + right;
        }
        case 'subtract': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left - right;
        }
        case 'multiply': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left * right;
        }
        case 'divide': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?' || right === 0) return '?';
          return left / right;
        }
        case 'power': {
          const base = this.calculateResult(sourceNode.id, 'base');
          const exp = this.calculateResult(sourceNode.id, 'exp');
          if (base === '?' || exp === '?') return '?';
          return Math.pow(base, exp);
        }
        case 'modulo': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?' || right === 0) return '?';
          return left % right;
        }
        
        // Advanced Math
        case 'sqrt': {
          const value = this.calculateResult(sourceNode.id, 'value');
          const root = this.calculateResult(sourceNode.id, 'root');
          
          // Default to square root if no root specified
          const rootValue = (root === '?' || root === null || root === undefined) ? 2 : root;
          
          if (value === '?' || value < 0 || rootValue === 0) return '?';
          return Math.pow(value, 1 / rootValue);
        }
        case 'log': {
          const value = this.calculateResult(sourceNode.id, 'value');
          const base = this.calculateResult(sourceNode.id, 'base');
          
          // Default to log base 10 if no base specified
          const baseValue = (base === '?' || base === null || base === undefined) ? 10 : base;
          
          if (value === '?' || value <= 0 || baseValue === '?' || baseValue <= 0 || baseValue === 1) return '?';
          return Math.log(value) / Math.log(baseValue);
        }
        case 'ln': {
          const input = this.calculateResult(sourceNode.id, 'in');
          if (input === '?' || input <= 0) return '?';
          return Math.log(input);
        }
        case 'abs': {
          const input = this.calculateResult(sourceNode.id, 'in');
          if (input === '?') return '?';
          return Math.abs(input);
        }
        
        // Trigonometry
        case 'sin': {
          const input = this.calculateResult(sourceNode.id, 'in');
          if (input === '?') return '?';
          return Math.sin(input);
        }
        case 'cos': {
          const input = this.calculateResult(sourceNode.id, 'in');
          if (input === '?') return '?';
          return Math.cos(input);
        }
        case 'tan': {
          const input = this.calculateResult(sourceNode.id, 'in');
          if (input === '?') return '?';
          return Math.tan(input);
        }
        
        // Comparison
        case 'equals': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left === right ? 1 : 0;
        }
        case 'greater': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left > right ? 1 : 0;
        }
        case 'less': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left < right ? 1 : 0;
        }
        case 'greaterEqual': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left >= right ? 1 : 0;
        }
        case 'lessEqual': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left <= right ? 1 : 0;
        }
        case 'notEqual': {
          const left = this.calculateResult(sourceNode.id, 'in1');
          const right = this.calculateResult(sourceNode.id, 'in2');
          if (left === '?' || right === '?') return '?';
          return left !== right ? 1 : 0;
        }
        
        // Advanced Components
        case 'component': {
          console.log('🎯 Component case triggered for:', nodeId, portId);
          // Extract the component output port from the connection
          const componentOutputPort = connection.from.split('-').pop();
          console.log('🔍 Component output port:', componentOutputPort);
          return this.calculateComponentResult(sourceNode.id, componentOutputPort);
        }
        case 'conditional': {
          // Rule engine logic: evaluate rules in order and return first match
          const inputValue = this.calculateResult(sourceNode.id, 'value');
          if (inputValue === '?') return '?';
          
          // Get rules from node (default to simple > 0 check if none exist)
          const rules = sourceNode.rules || [
            { type: 'greater', value: 0, returnValue: 1, enabled: true },
            { type: 'default', returnValue: 0, enabled: true }
          ];
          
          // Evaluate rules in order
          for (const rule of rules) {
            if (!rule.enabled) continue;
            
            let matches = false;
            switch (rule.type) {
              case 'greater':
                matches = inputValue > (rule.value || 0);
                break;
              case 'less':
                matches = inputValue < (rule.value || 0);
                break;
              case 'equals':
                matches = inputValue === (rule.value || 0);
                break;
              case 'range': {
                const min = rule.value || 0;
                const max = rule.maxValue || 10;
                matches = inputValue >= min && inputValue <= max;
                break;
              }
              case 'negative':
                matches = inputValue < 0;
                break;
              case 'positive':
                matches = inputValue > 0;
                break;
              case 'zero':
                matches = inputValue === 0;
                break;
              case 'default':
                matches = true; // Always matches (catch-all)
                break;
            }
            
            if (matches) {
              return rule.returnValue || 0;
            }
          }
          
          // If no rule matched (shouldn't happen with default rule), return 0
          return 0;
        }

        // Component I/O nodes
        case 'componentInput': {
          // Component input nodes get their values from the main equation context
          // For now, return a placeholder value (needs proper integration)
          return sourceNode.value || 0;
        }
        case 'componentOutput': {
          // Component output nodes pass through their input value
          const input = this.calculateResult(sourceNode.id, 'in');
          return input !== '?' ? input : 0;
        }
        
        // Multiplexer node - select between choice inputs based on selector value  
        case 'multiplexer': {
          const selector = this.calculateResult(sourceNode.id, 'selector');
          if (selector === '?') return '?';
          
          // Round selector to nearest integer and use as choice index
          const choiceIndex = Math.round(selector);
          const choicePort = `choice${choiceIndex}`;
          
          // Check if the choice port exists on this node
          if (sourceNode.inputs && sourceNode.inputs.includes(choicePort)) {
            const selectedChoice = this.calculateResult(sourceNode.id, choicePort);
            return selectedChoice !== '?' ? selectedChoice : 0;
          } else {
            // If choice index is out of range, return 0
            return 0;
          }
        }
        
        // Splitter node - pass input value to all outputs
        case 'splitter': {
          const input = this.calculateResult(sourceNode.id, 'input');
          return input !== '?' ? input : 0;
        }
        
        default:
          return '?';
      }
    }

    buildEquation(nodeId, portId) {
      console.log('🔍 buildEquation called:', nodeId, portId);
      
      const connection = this.connections.find(conn => conn.to === `${nodeId}-${portId}`);
      if (!connection) {
        console.log('❌ No connection found to:', `${nodeId}-${portId}`);
        return '';
      }
      
      console.log('🔗 Found connection:', connection);

      // Parse source node ID properly (e.g., "node-1-1234567-out" -> "node-1-1234567")
      const fromParts = connection.from.split('-');
      fromParts.pop(); // Remove port id
      const sourceNodeId = fromParts.join('-');
      
      console.log('📍 Source node ID:', sourceNodeId);
      
      const sourceNode = this.nodes.get(sourceNodeId);
      if (!sourceNode) {
        console.log('❌ Source node not found:', sourceNodeId);
        return '';
      }
      
      console.log('✅ Source node found:', sourceNode);

      switch (sourceNode.type) {
        // Generators
        case 'number':
          return sourceNode.value?.toString() || '0';
        case 'variable':
          return sourceNode.variable || 'x';
        case 'constant_pi':
          return 'π';
        case 'constant_e':
          return 'e';
        case 'constant_phi':
          return 'φ'; // φ (golden ratio)
        case 'constant_sqrt2':
          return '√2'; // √2
          
        // Binary Operators
        case 'add':
        case 'subtract':
        case 'multiply':
        case 'divide':
        case 'modulo':
        case 'equals':
        case 'greater':
        case 'less':
        case 'greaterEqual':
        case 'lessEqual':
        case 'notEqual': {
          const left = this.buildEquation(sourceNode.id, 'in1');
          const right = this.buildEquation(sourceNode.id, 'in2');
          if (!left || !right) return '';
          
          const operators = { 
            add: '+', subtract: '-', multiply: '*', divide: '/', modulo: '%',
            equals: '=', greater: '>', less: '<', greaterEqual: '≥', lessEqual: '≤', notEqual: '≠'
          };
          const op = operators[sourceNode.type];
          return `(${left} ${op} ${right})`;
        }
        
        case 'power': {
          const base = this.buildEquation(sourceNode.id, 'base');
          const exp = this.buildEquation(sourceNode.id, 'exp');
          if (!base || !exp) return '';
          return `(${base}^${exp})`;
        }
        
        // Unary Operators
        case 'sqrt': {
          const value = this.buildEquation(sourceNode.id, 'value');
          const root = this.buildEquation(sourceNode.id, 'root');
          
          if (!value) return '';
          
          // If root is specified and not default 2, show nth root notation
          if (root && root !== '2') {
            return `${root}√(${value})`;
          } else {
            return `√(${value})`;
          }
        }
        case 'log': {
          const value = this.buildEquation(sourceNode.id, 'value');
          const base = this.buildEquation(sourceNode.id, 'base');
          
          if (!value) return '';
          
          // If base is specified and not default 10, show subscript base
          if (base && base !== '10') {
            return `log_${base}(${value})`;
          } else {
            return `log(${value})`;
          }
        }
        case 'ln': {
          const input = this.buildEquation(sourceNode.id, 'in');
          if (!input) return '';
          return `ln(${input})`;
        }
        case 'abs': {
          const input = this.buildEquation(sourceNode.id, 'in');
          if (!input) return '';
          return `|${input}|`;
        }
        case 'sin': {
          const input = this.buildEquation(sourceNode.id, 'in');
          if (!input) return '';
          return `sin(${input})`;
        }
        case 'cos': {
          const input = this.buildEquation(sourceNode.id, 'in');
          if (!input) return '';
          return `cos(${input})`;
        }
        case 'tan': {
          const input = this.buildEquation(sourceNode.id, 'in');
          if (!input) return '';
          return `tan(${input})`;
        }
        
        // Advanced Components
        case 'component': {
          // Get the port ID from the connection
          const sourcePortId = connection.from.split('-').pop();
          return this.buildComponentEquation(sourceNodeId, sourcePortId);
        }
        case 'conditional': {
          // Rule engine equation building
          const inputEquation = this.buildEquation(sourceNode.id, 'value');
          if (!inputEquation) return '';
          
          const rules = sourceNode.rules || [
            { type: 'greater', value: 0, returnValue: 1, enabled: true },
            { type: 'default', returnValue: 0, enabled: true }
          ];
          
          // Build a readable rule description
          const activeRules = rules.filter(r => r.enabled);
          if (activeRules.length === 0) return 'RULES()';
          
          const ruleDescriptions = activeRules.map(rule => {
            switch (rule.type) {
              case 'greater': return `${inputEquation} > ${rule.value} → ${rule.returnValue}`;
              case 'less': return `${inputEquation} < ${rule.value} → ${rule.returnValue}`;
              case 'equals': return `${inputEquation} = ${rule.value} → ${rule.returnValue}`;
              case 'range': return `${rule.value} ≤ ${inputEquation} ≤ ${rule.maxValue} → ${rule.returnValue}`;
              case 'negative': return `${inputEquation} < 0 → ${rule.returnValue}`;
              case 'positive': return `${inputEquation} > 0 → ${rule.returnValue}`;
              case 'zero': return `${inputEquation} = 0 → ${rule.returnValue}`;
              case 'default': return `default → ${rule.returnValue}`;
              default: return `${rule.type} → ${rule.returnValue}`;
            }
          });
          
          return `RULES(${ruleDescriptions.join('; ')})`;
        }

        // Component I/O nodes
        case 'componentInput': {
          return sourceNode.label || 'Input';
        }
        case 'componentOutput': {
          const input = this.buildEquation(sourceNode.id, 'in');
          return input || 'Output';
        }
        
        // Multiplexer node - shows selector and choice count
        case 'multiplexer': {
          const selector = this.buildEquation(sourceNode.id, 'selector');
          if (!selector) return 'MUX(?)';
          
          const choiceCount = (sourceNode.inputs || []).length - 1; // Subtract selector port
          return `MUX[${choiceCount}](${selector})`;
        }
        
        // Splitter node - shows input being split to multiple outputs
        case 'splitter': {
          const input = this.buildEquation(sourceNode.id, 'input');
          const outputCount = (sourceNode.outputs || []).length;
          return input ? `SPLIT[${outputCount}](${input})` : `SPLIT[${outputCount}](?)`;
        }
        
        default:
          return '';
      }
    }

    setupTables() {
      const showTablesBtn = document.getElementById('show-tables-btn');
      const tablesSidebar = document.getElementById('tables-sidebar');
      
      // Show/hide tables sidebar
      showTablesBtn.addEventListener('click', () => {
        if (tablesSidebar.classList.contains('open')) {
          // Close sidebar if already open
          tablesSidebar.classList.remove('open');
          showTablesBtn.textContent = 'Show Tables';
        } else {
          // Open sidebar
          tablesSidebar.classList.add('open');
          showTablesBtn.textContent = 'Hide Tables';
          this.updateTables();
        }
      });

      // Close sidebar via close button
      document.getElementById('close-tables-sidebar').addEventListener('click', () => {
        tablesSidebar.classList.remove('open');
        showTablesBtn.textContent = 'Show Tables';
      });

      // Section toggles
      document.getElementById('toggle-variables').addEventListener('click', () => {
        const section = document.getElementById('variables-section');
        const button = document.getElementById('toggle-variables');
        section.classList.toggle('collapsed');
        button.textContent = section.classList.contains('collapsed') ? '+' : '−';
      });

      document.getElementById('toggle-equations').addEventListener('click', () => {
        const section = document.getElementById('equations-section');
        const button = document.getElementById('toggle-equations');
        section.classList.toggle('collapsed');
        button.textContent = section.classList.contains('collapsed') ? '+' : '−';
      });
    }



    updateTables() {
      this.updateVariablesTable();
      this.updateEquationsTable();
    }

    updateVariablesTable() {
      const tbody = document.getElementById('variables-tbody');
      tbody.innerHTML = '';

      for (const [varName, varData] of this.globalVariables.entries()) {
        if (varData.inTable) {
          const row = document.createElement('tr');
          const nameCell = document.createElement('td');
          const valueCell = document.createElement('td');
          
          nameCell.textContent = varName;
          
          // Create editable input for value
          const valueInput = document.createElement('input');
          valueInput.type = 'number';
          valueInput.step = '0.1';
          valueInput.value = varData.isSet ? varData.value : '';
          valueInput.placeholder = 'symbolic';
          valueInput.style.cssText = 'width: 100%; border: none; background: transparent; padding: 4px;';
          
          // Add event listener to update global variable
          valueInput.addEventListener('input', (e) => {
            const value = e.target.value;
            varData.value = value;
            varData.isSet = value !== '';
            this.updateEquation(); // Recalculate equations
          });
          
          // Add focus styles
          valueInput.addEventListener('focus', () => {
            valueInput.style.background = '#f0f9ff';
            valueInput.style.border = '1px solid #3b82f6';
          });
          
          valueInput.addEventListener('blur', () => {
            valueInput.style.background = 'transparent';
            valueInput.style.border = 'none';
          });
          
          valueCell.appendChild(valueInput);
          
          row.appendChild(nameCell);
          row.appendChild(valueCell);
          tbody.appendChild(row);
        }
      }
    }

    updateEquationsTable() {
      const tbody = document.getElementById('equations-tbody');
      tbody.innerHTML = '';

      for (const [outputId, outputData] of this.globalOutputs.entries()) {
        if (outputData.inTable) {
          const row = document.createElement('tr');
          const latexCell = document.createElement('td');
          latexCell.className = 'latex-cell';
          
          row.innerHTML = `
            <td>${outputData.name}</td>
            <td>${outputData.result}</td>
          `;
          
          // Insert LaTeX cell at position 1 (between name and result)
          const nameCell = row.children[0];
          const resultCell = row.children[1];
          row.insertBefore(latexCell, resultCell);
          
          // Render LaTeX for equation
          const latexEquation = outputData.latexEquation || this.convertToLatex(outputData.equation);
          this.renderLatex(latexCell, latexEquation);
          
          tbody.appendChild(row);
        }
      }
    }

    renderLatex(element, latexString) {
      // Wait for KaTeX to be available
      if (typeof katex !== 'undefined') {
        try {
          katex.render(latexString, element, {
            throwOnError: false,
            displayMode: false
          });
        } catch (error) {
          console.warn('LaTeX rendering error:', error);
          element.textContent = latexString;
        }
      } else {
        // Fallback if KaTeX isn't loaded yet
        element.textContent = latexString;
        // Try again after a brief delay
        setTimeout(() => {
          if (typeof katex !== 'undefined') {
            try {
              katex.render(latexString, element, {
                throwOnError: false,
                displayMode: false
              });
            } catch (error) {
              console.warn('LaTeX rendering error:', error);
            }
          }
        }, 100);
      }
    }

    setMainEquationDisplay(outputNodeId, equation, result) {
      if (!equation) return;
      
      // Show equation instead of NaN for non-numeric results
      const displayResult = (result === null || result === undefined || isNaN(result)) ? 
        equation : result;
      
      this.equationDisplay.textContent = `${equation} = ${displayResult}`;
      this.equationDisplay.style.color = '#1e293b';
    }

    buildLatexEquation(nodeId, portId) {
      const connection = this.connections.find(conn => conn.to === `${nodeId}-${portId}`);
      if (!connection) return '';
      
      // Parse source node ID properly
      const fromParts = connection.from.split('-');
      fromParts.pop(); // Remove port id
      const sourceNodeId = fromParts.join('-');
      
      const sourceNode = this.nodes.get(sourceNodeId);
      if (!sourceNode) return '';

      switch (sourceNode.type) {
        // Generators
        case 'number':
          return sourceNode.value?.toString() || '0';
        case 'variable':
          return sourceNode.variable || 'x';
        case 'constant_pi':
          return '\\pi';
        case 'constant_e':
          return 'e';
        case 'constant_phi':
          return '\\phi'; // φ (golden ratio)
        case 'constant_sqrt2':
          return '\\sqrt{2}'; // √2
          
        // Binary Operators
        case 'add':
        case 'subtract': {
          const left = this.buildLatexEquation(sourceNode.id, 'in1');
          const right = this.buildLatexEquation(sourceNode.id, 'in2');
          if (!left || !right) return '';
          
          const op = sourceNode.type === 'add' ? '+' : '-';
          return `${left} ${op} ${right}`;
        }
        
        case 'multiply': {
          const left = this.buildLatexEquation(sourceNode.id, 'in1');
          const right = this.buildLatexEquation(sourceNode.id, 'in2');
          if (!left || !right) return '';
          return `${left} \\cdot ${right}`;
        }
        
        case 'divide': {
          const left = this.buildLatexEquation(sourceNode.id, 'in1');
          const right = this.buildLatexEquation(sourceNode.id, 'in2');
          if (!left || !right) return '';
          return `\\frac{${left}}{${right}}`;
        }
        
        case 'power': {
          const base = this.buildLatexEquation(sourceNode.id, 'base');
          const exp = this.buildLatexEquation(sourceNode.id, 'exp');
          if (!base || !exp) return '';
          return `${base}^{${exp}}`;
        }
        
        // Unary Operators  
        case 'sqrt': {
          const value = this.buildLatexEquation(sourceNode.id, 'value');
          const root = this.buildLatexEquation(sourceNode.id, 'root');
          
          if (!value) return '';
          
          if (root && root !== '2') {
            return `\\sqrt[${root}]{${value}}`;
          } else {
            return `\\sqrt{${value}}`;
          }
        }
        
        case 'log': {
          const value = this.buildLatexEquation(sourceNode.id, 'value');
          const base = this.buildLatexEquation(sourceNode.id, 'base');
          
          if (!value) return '';
          
          if (base && base !== '10') {
            return `\\log_{${base}}\\left(${value}\\right)`;
          } else {
            return `\\log\\left(${value}\\right)`;
          }
        }
        
        case 'ln': {
          const input = this.buildLatexEquation(sourceNode.id, 'in');
          if (!input) return '';
          return `\\ln\\left(${input}\\right)`;
        }
        
        case 'abs': {
          const input = this.buildLatexEquation(sourceNode.id, 'in');
          if (!input) return '';
          return `\\left|${input}\\right|`;
        }
        
        case 'sin':
        case 'cos':
        case 'tan': {
          const input = this.buildLatexEquation(sourceNode.id, 'in');
          if (!input) return '';
          return `\\${sourceNode.type}\\left(${input}\\right)`;
        }
        
        case 'modulo': {
          const left = this.buildLatexEquation(sourceNode.id, 'in1');
          const right = this.buildLatexEquation(sourceNode.id, 'in2');
          if (!left || !right) return '';
          return `${left} \\bmod ${right}`;
        }
        
        default:
          return '';
      }
    }

    convertToLatex(equation) {
      // This method is now simplified since we have buildLatexEquation
      if (!equation) return '';
      
      // Basic fallback conversion for any missed cases
      return equation
        .replace(/π/g, '\\pi')
        .replace(/\*/g, ' \\cdot ')
        .replace(/sqrt\(/g, '\\sqrt{')
        .replace(/\|([^|]+)\|/g, '\\left|$1\\right|');
    }

    // Session Management Methods
    exportSession() {
      try {
        const sessionData = {
          timestamp: new Date().toISOString(),
          version: '1.0',
          appName: 'Visual Equation Builder',
          data: {
            nodes: Array.from(this.nodes.entries()).map(([id, node]) => [id, {
              ...node,
              element: null, // Don't serialize DOM elements
              // Ensure inputs/outputs are preserved
              inputs: node.inputs || [],
              outputs: node.outputs || []
            }]),
            connections: [...this.connections],
            globalVariables: Array.from(this.globalVariables.entries()),
            globalOutputs: Array.from(this.globalOutputs.entries())
          }
        };

        // Create downloadable file
        const jsonString = JSON.stringify(sessionData, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        // Create download link
        const link = document.createElement('a');
        link.href = url;
        link.download = `equation-builder-session-${new Date().toISOString().slice(0, 16).replace(/:/g, '-')}.json`;
        
        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        return true;
      } catch (error) {
        console.error('Failed to export session:', error);
        alert('Failed to export session. Please try again.');
        return false;
      }
    }

    // Separate auto-save method for localStorage
    autoSave() {
      try {
        const sessionData = {
          timestamp: new Date().toISOString(),
          version: '1.0',
          data: {
            nodes: Array.from(this.nodes.entries()).map(([id, node]) => [id, {
              ...node,
              element: null, // Don't serialize DOM elements
              // Ensure inputs/outputs are preserved
              inputs: node.inputs || [],
              outputs: node.outputs || []
            }]),
            connections: [...this.connections],
            globalVariables: Array.from(this.globalVariables.entries()),
            globalOutputs: Array.from(this.globalOutputs.entries())
          }
        };

        localStorage.setItem('equation_builder_autosave', JSON.stringify(sessionData));
        this.showAutoSaveIndicator();
        return true;
      } catch (error) {
        console.warn('Auto-save failed:', error);
        return false;
      }
    }

    importSession(fileContent) {
      try {
        const sessionData = JSON.parse(fileContent);
        
        // Validate session data structure
        if (!sessionData.data || !sessionData.version) {
          throw new Error('Invalid session file format');
        }

        // Clear current state
        this.clearCanvas('full');

        // Restore data
        const { nodes, connections, globalVariables, globalOutputs } = sessionData.data;
        
        // Restore nodes - clear first to avoid ID conflicts
        this.nodes.clear();
        
        // Directly restore nodes with original IDs (don't use addNode which generates new IDs)
        nodes.forEach(([id, nodeData]) => {
          // Extract position properly - it's stored as nodeData.position, not nodeData.x/y
          const position = nodeData.position || { x: 50, y: 50 };
          
          // Restore node data with original ID
          const restoredNode = {
            ...nodeData,
            id: id, // Preserve original ID
            position: position, // Use the actual saved position
            inputs: nodeData.inputs || [], // Ensure inputs exist
            outputs: nodeData.outputs || [] // Ensure outputs exist
          };
          
          // Add to nodes map
          this.nodes.set(id, restoredNode);
          
          // Render the DOM element
          this.renderNode(restoredNode);
        });

        // Restore connections
        this.connections = [...connections];
        
        // Restore global state
        this.globalVariables = new Map(globalVariables);
        this.globalOutputs = new Map(globalOutputs);

        // Update visual state
        this.updateConnections();
        this.updateVariablesTable();
        this.updateEquationsTable(); // This already updates outputs

        alert(`Session imported successfully! (${new Date(sessionData.timestamp).toLocaleString()})`);
        return true;
      } catch (error) {
        console.error('Failed to import session:', error);
        alert('Failed to import session. The file may be corrupted or invalid.');
        return false;
      }
    }

    // Load auto-save from localStorage
    loadAutoSave() {
      try {
        const sessionData = JSON.parse(localStorage.getItem('equation_builder_autosave'));
        if (!sessionData) {
          alert('No auto-saved session found.');
          return false;
        }

        // Use the same import logic
        return this.importSession(JSON.stringify(sessionData));
      } catch (error) {
        console.error('Failed to load auto-save:', error);
        alert('Failed to load auto-saved session.');
        return false;
      }
    }

    hasAutoSave() {
      return localStorage.getItem('equation_builder_autosave') !== null;
    }

    // Multi-selection system
    setupMultiSelection() {
      // Keyboard event listeners for copy/cut/paste
      document.addEventListener('keydown', (e) => {
        // Only handle shortcuts when not typing in inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        if (e.ctrlKey || e.metaKey) {
          switch (e.key.toLowerCase()) {
            case 'c':
              e.preventDefault();
              this.copySelectedNodes();
              break;
            case 'x':
              e.preventDefault();
              this.cutSelectedNodes();
              break;
            case 'v':
              e.preventDefault();
              this.pasteNodes();
              break;
            case 'a':
              e.preventDefault();
              this.selectAllNodes();
              break;
          }
        }
        
        // Delete key to remove selected nodes
        if (e.key === 'Delete' && this.selectedNodes.size > 0) {
          e.preventDefault();
          this.deleteSelectedNodes();
        }
        
        // Escape to clear selection
        if (e.key === 'Escape') {
          this.clearSelection();
        }
      });
      
      // Setup drag selection on canvas
      this.setupDragSelection();
      
      // Setup selection action buttons
      this.setupSelectionActions();
    }
    
    setupDragSelection() {
      // Canvas mouse events for drag selection
      this.canvas.addEventListener('mousedown', (e) => {
        // Only start drag selection if clicking on canvas background (not nodes)
        if (e.target === this.canvas || e.target === this.connectionsSvg) {
          this.startDragSelection(e);
        }
      });
      
      document.addEventListener('mousemove', (e) => {
        if (this.isDragSelecting) {
          this.updateDragSelection(e);
        }
      });
      
      document.addEventListener('mouseup', (e) => {
        if (this.isDragSelecting) {
          this.endDragSelection(e);
        }
      });
    }
    
    startDragSelection(e) {
      this.isDragSelecting = true;
      const canvasRect = this.canvas.getBoundingClientRect();
      this.dragStartX = e.clientX - canvasRect.left;
      this.dragStartY = e.clientY - canvasRect.top;
      
      // Clear existing selection unless Ctrl is held
      if (!e.ctrlKey) {
        this.clearSelection();
      }
      
      // Create selection rectangle element
      this.selectionRectangle = document.createElement('div');
      this.selectionRectangle.className = 'selection-rectangle';
      this.selectionRectangle.style.position = 'absolute';
      this.selectionRectangle.style.left = this.dragStartX + 'px';
      this.selectionRectangle.style.top = this.dragStartY + 'px';
      this.selectionRectangle.style.width = '0px';
      this.selectionRectangle.style.height = '0px';
      this.canvas.appendChild(this.selectionRectangle);
    }
    
    updateDragSelection(e) {
      if (!this.selectionRectangle) return;
      
      const canvasRect = this.canvas.getBoundingClientRect();
      const currentX = e.clientX - canvasRect.left;
      const currentY = e.clientY - canvasRect.top;
      
      const left = Math.min(this.dragStartX, currentX);
      const top = Math.min(this.dragStartY, currentY);
      const width = Math.abs(currentX - this.dragStartX);
      const height = Math.abs(currentY - this.dragStartY);
      
      this.selectionRectangle.style.left = left + 'px';
      this.selectionRectangle.style.top = top + 'px';
      this.selectionRectangle.style.width = width + 'px';
      this.selectionRectangle.style.height = height + 'px';
      
      // Find nodes within selection rectangle and highlight them
      this.highlightNodesInSelection(left, top, width, height);
    }
    
    endDragSelection(e) {
      if (!this.isDragSelecting) return;
      
      this.isDragSelecting = false;
      this.justFinishedDragSelection = true; // Prevent click handler from clearing selection
      
      // Remove selection rectangle
      if (this.selectionRectangle) {
        this.selectionRectangle.remove();
        this.selectionRectangle = null;
      }
      
      // Finalize selection
      this.updateNodeSelectionVisuals();
    }
    
    highlightNodesInSelection(selectionLeft, selectionTop, selectionWidth, selectionHeight) {
      const selectionRight = selectionLeft + selectionWidth;
      const selectionBottom = selectionTop + selectionHeight;
      
      for (const [nodeId, node] of this.nodes.entries()) {
        const nodeEl = document.getElementById(nodeId);
        if (!nodeEl) continue;
        
        const nodeRect = nodeEl.getBoundingClientRect();
        const canvasRect = this.canvas.getBoundingClientRect();
        
        // Convert node position to canvas coordinates
        const nodeLeft = nodeRect.left - canvasRect.left;
        const nodeTop = nodeRect.top - canvasRect.top;
        const nodeRight = nodeLeft + nodeRect.width;
        const nodeBottom = nodeTop + nodeRect.height;
        
        // Check if node intersects with selection rectangle
        const intersects = !(nodeRight < selectionLeft || 
                           nodeLeft > selectionRight || 
                           nodeBottom < selectionTop || 
                           nodeTop > selectionBottom);
        
        if (intersects) {
          this.selectedNodes.add(nodeId);
        }
      }
    }
    
    setupSelectionActions() {
      // Button event listeners with safety checks
      const copyBtn = document.getElementById('copy-selected');
      const cutBtn = document.getElementById('cut-selected');
      const deleteBtn = document.getElementById('delete-selected');
      const groupBtn = document.getElementById('group-selected');
      
      if (copyBtn) {
        copyBtn.addEventListener('click', () => {
          this.copySelectedNodes();
        });
      }
      
      if (cutBtn) {
        cutBtn.addEventListener('click', () => {
          this.cutSelectedNodes();
        });
      }
      
      if (deleteBtn) {
        deleteBtn.addEventListener('click', () => {
          this.deleteSelectedNodes();
        });
      }
      
      if (groupBtn) {
        groupBtn.addEventListener('click', () => {
          this.groupSelectedNodes();
        });
      }
      
      // Keyboard shortcut for grouping
      document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'g' && this.selectedNodes.size > 1) {
          e.preventDefault();
          this.groupSelectedNodes();
        }
      });
    }
    
    groupSelectedNodes() {
      if (this.selectedNodes.size < 2) {
        console.log('Need at least 2 nodes to group');
        return;
      }
      
      // Calculate the bounding box of selected nodes
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      
      for (const nodeId of this.selectedNodes) {
        const nodeEl = document.getElementById(nodeId);
        if (nodeEl) {
          const rect = nodeEl.getBoundingClientRect();
          const canvasRect = this.canvas.getBoundingClientRect();
          const x = rect.left - canvasRect.left;
          const y = rect.top - canvasRect.top;
          
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x + rect.width);
          maxY = Math.max(maxY, y + rect.height);
        }
      }
      
      // Create a visual group indicator
      this.createGroupIndicator(minX, minY, maxX - minX, maxY - minY);
      
      console.log(`Grouped ${this.selectedNodes.size} nodes`);
    }
    
    createGroupIndicator(x, y, width, height) {
      // Remove any existing group indicators
      const existingIndicators = this.canvas.querySelectorAll('.group-indicator');
      existingIndicators.forEach(indicator => indicator.remove());
      
      // Create new group indicator
      const groupIndicator = document.createElement('div');
      groupIndicator.className = 'group-indicator';
      groupIndicator.style.position = 'absolute';
      groupIndicator.style.left = (x - 10) + 'px';
      groupIndicator.style.top = (y - 10) + 'px';
      groupIndicator.style.width = (width + 20) + 'px';
      groupIndicator.style.height = (height + 20) + 'px';
      groupIndicator.style.pointerEvents = 'none';
      groupIndicator.style.zIndex = '1';
      
      this.canvas.appendChild(groupIndicator);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        if (groupIndicator.parentNode) {
          groupIndicator.remove();
        }
      }, 3000);
    }

    // Selection management methods
    toggleNodeSelection(nodeId, multiSelect = false) {
      if (!multiSelect) {
        this.clearSelection();
      }
      
      if (this.selectedNodes.has(nodeId)) {
        this.selectedNodes.delete(nodeId);
      } else {
        this.selectedNodes.add(nodeId);
      }
      
      this.updateNodeSelectionVisuals();
    }

    clearSelection() {
      this.selectedNodes.clear();
      this.updateNodeSelectionVisuals();
    }

    selectAllNodes() {
      this.clearSelection();
      for (const nodeId of this.nodes.keys()) {
        this.selectedNodes.add(nodeId);
      }
      this.updateNodeSelectionVisuals();
    }

    updateNodeSelectionVisuals() {
      // Update visual selection indicators for all nodes
      for (const [nodeId, node] of this.nodes.entries()) {
        const nodeEl = document.getElementById(nodeId);
        if (nodeEl) {
          if (this.selectedNodes.has(nodeId)) {
            nodeEl.classList.add('selected');
          } else {
            nodeEl.classList.remove('selected');
          }
        }
      }
      
      // Update selection status display
      this.updateSelectionStatus();
    }
    
    updateSelectionStatus() {
      const statusEl = document.getElementById('selection-status');
      if (!statusEl) return; // Safety check - element might not be ready yet
      
      const countEl = statusEl.querySelector('.selection-count');
      if (!countEl) return; // Safety check for nested element
      
      const selectedCount = this.selectedNodes.size;
      
      if (selectedCount > 0) {
        statusEl.style.display = 'flex';
        countEl.textContent = `${selectedCount} node${selectedCount === 1 ? '' : 's'} selected`;
      } else {
        statusEl.style.display = 'none';
      }
    }

    // Clipboard operations
    copySelectedNodes() {
      if (this.selectedNodes.size === 0) return;
      
      // Serialize selected nodes and their connections
      const selectedNodeData = [];
      const selectedConnections = [];
      
      // Copy nodes
      for (const nodeId of this.selectedNodes) {
        const node = this.nodes.get(nodeId);
        if (node) {
          selectedNodeData.push([nodeId, {
            ...node,
            element: null // Don't serialize DOM elements
          }]);
        }
      }
      
      // Copy connections between selected nodes
      for (const connection of this.connections) {
        const fromNodeId = connection.from.split('-').slice(0, -1).join('-');
        const toNodeId = connection.to.split('-').slice(0, -1).join('-');
        
        if (this.selectedNodes.has(fromNodeId) && this.selectedNodes.has(toNodeId)) {
          selectedConnections.push(connection);
        }
      }
      
      this.clipboard = {
        nodes: selectedNodeData,
        connections: selectedConnections,
        operation: 'copy'
      };
      
      console.log(`Copied ${this.selectedNodes.size} nodes to clipboard`);
    }

    cutSelectedNodes() {
      this.copySelectedNodes();
      if (this.clipboard) {
        this.clipboard.operation = 'cut';
        this.deleteSelectedNodes();
      }
    }

    pasteNodes() {
      if (!this.clipboard || this.clipboard.nodes.length === 0) return;
      
      const canvasRect = this.canvas.getBoundingClientRect();
      const pasteOffset = { x: 50, y: 50 }; // Offset from original position
      
      // Map old IDs to new IDs
      const idMapping = new Map();
      
      // Create new nodes with new IDs
      for (const [oldId, nodeData] of this.clipboard.nodes) {
        const newId = this.generateId();
        idMapping.set(oldId, newId);
        
        // Offset position for paste
        const newPosition = {
          x: (nodeData.position?.x || 50) + pasteOffset.x,
          y: (nodeData.position?.y || 50) + pasteOffset.y
        };
        
        const newNode = {
          ...nodeData,
          id: newId,
          position: newPosition
        };
        
        this.nodes.set(newId, newNode);
        this.renderNode(newNode);
      }
      
      // Create connections with new IDs
      for (const connection of this.clipboard.connections) {
        const fromParts = connection.from.split('-');
        const toParts = connection.to.split('-');
        
        const fromNodeId = fromParts.slice(0, -1).join('-');
        const toNodeId = toParts.slice(0, -1).join('-');
        const fromPort = fromParts[fromParts.length - 1];
        const toPort = toParts[toParts.length - 1];
        
        const newFromId = idMapping.get(fromNodeId);
        const newToId = idMapping.get(toNodeId);
        
        if (newFromId && newToId) {
          const newConnection = {
            from: `${newFromId}-${fromPort}`,
            to: `${newToId}-${toPort}`
          };
          this.connections.push(newConnection);
        }
      }
      
      // Update visual connections
      this.updateConnections();
      
      // Select pasted nodes
      this.clearSelection();
      for (const newId of idMapping.values()) {
        this.selectedNodes.add(newId);
      }
      this.updateNodeSelectionVisuals();
      
      console.log(`Pasted ${idMapping.size} nodes`);
    }

    deleteSelectedNodes() {
      if (this.selectedNodes.size === 0) return;
      
      // Remove connections involving selected nodes
      this.connections = this.connections.filter(conn => {
        const fromNodeId = conn.from.split('-').slice(0, -1).join('-');
        const toNodeId = conn.to.split('-').slice(0, -1).join('-');
        return !this.selectedNodes.has(fromNodeId) && !this.selectedNodes.has(toNodeId);
      });
      
      // Remove nodes from DOM and data structure
      for (const nodeId of this.selectedNodes) {
        const nodeEl = document.getElementById(nodeId);
        if (nodeEl) {
          nodeEl.remove();
        }
        this.nodes.delete(nodeId);
        this.globalOutputs.delete(nodeId); // Clean up output data if it's an output node
      }
      
      this.clearSelection();
      this.updateConnections();
      this.updateVariablesTable();
      this.updateEquationsTable();
      
      console.log('Deleted selected nodes');
    }

    // Component-specific import/export methods
    exportComponent() {
      if (!this.isEditingComponent) {
        alert('You must be editing a component to export it.');
        return;
      }

      try {
        // Export only the current component's nodes and connections
        const componentData = {
          version: '1.0',
          type: 'component',
          name: document.getElementById('comp-name-input')?.value || 'Component',
          timestamp: new Date().toISOString(),
          data: {
            nodes: Array.from(this.nodes.entries()).map(([id, node]) => [id, {
              ...node,
              // Position is already stored as node.position, no need to flatten to x/y
              element: null // Don't serialize DOM elements
            }]),
            connections: [...this.connections],
            globalVariables: Array.from(this.globalVariables.entries()),
            globalOutputs: Array.from(this.globalOutputs.entries())
          }
        };

        const jsonData = JSON.stringify(componentData, null, 2);
        const blob = new Blob([jsonData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `${componentData.name.replace(/[^a-zA-Z0-9]/g, '_')}_component.json`;
        a.click();
        
        URL.revokeObjectURL(url);
        alert(`Component "${componentData.name}" exported successfully!`);
      } catch (error) {
        console.error('Failed to export component:', error);
        alert('Failed to export component.');
      }
    }

    importComponent() {
      if (!this.isEditingComponent) {
        alert('You must be editing a component to import into it.');
        return;
      }

      // Create hidden file input for component import
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.style.display = 'none';
      
      input.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const componentData = JSON.parse(e.target.result);
              
              // Validate component data structure
              if (!componentData.data || componentData.type !== 'component') {
                throw new Error('Invalid component file format');
              }

              // Clear current component content
              this.nodes.clear();
              this.connections = [];
              this.clearCanvas();

              // Import component data (same logic as regular import but for components)
              const { nodes, connections } = componentData.data;
              
              nodes.forEach(([id, nodeData]) => {
                // Extract position properly - it's stored as nodeData.position, not nodeData.x/y
                const position = nodeData.position || { x: 50, y: 50 };
                
                const restoredNode = {
                  ...nodeData,
                  id: id,
                  position: position, // Use the actual saved position
                  inputs: nodeData.inputs || [],
                  outputs: nodeData.outputs || []
                };
                
                this.nodes.set(id, restoredNode);
                this.renderNode(restoredNode);
              });

              this.connections = [...connections];
              this.updateConnections();

              // Update component name in the overlay
              const nameInput = document.getElementById('comp-name-input');
              if (nameInput && componentData.name) {
                nameInput.value = componentData.name;
              }

              alert(`Component "${componentData.name || 'Component'}" imported successfully!`);
            } catch (error) {
              console.error('Failed to import component:', error);
              alert('Failed to import component. The file may be corrupted or invalid.');
            }
          };
          reader.readAsText(file);
        }
        
        // Clean up
        document.body.removeChild(input);
      });
      
      document.body.appendChild(input);
      input.click();
    }

    showAutoSaveIndicator() {
      const indicator = document.getElementById('auto-save-indicator');
      indicator.classList.add('show');
      setTimeout(() => {
        indicator.classList.remove('show');
      }, 3000);
    }

    // Auto-save functionality with debouncing
    setupAutoSave() {
      let autoSaveTimeout;
      const triggerAutoSave = () => {
        clearTimeout(autoSaveTimeout);
        autoSaveTimeout = setTimeout(() => {
          if (this.nodes.size > 0 || this.connections.length > 0) {
            this.autoSave();
          }
        }, 2000); // Auto-save after 2 seconds of inactivity
      };

      // Auto-save on canvas changes
      const canvas = document.getElementById('equation-canvas');
      const observer = new MutationObserver(triggerAutoSave);
      observer.observe(canvas, { childList: true, subtree: true });

      // Auto-save on connection changes (we'll call this manually when connections change)
      this.autoSaveCallback = triggerAutoSave;
    }
  }

  // Initialize when DOM is ready
  let equationBuilder;
  document.addEventListener('DOMContentLoaded', () => {
    equationBuilder = new CleanEquationBuilder();
    
    // Set up auto-save
    equationBuilder.setupAutoSave();
    
    // Check for auto-saved session and prompt user to restore
    if (equationBuilder.hasAutoSave()) {
      if (confirm('We found an auto-saved session. Would you like to restore it?')) {
        equationBuilder.loadAutoSave();
      }
    }
    
    // Session Management Event Listeners
    document.getElementById('export-session-btn').addEventListener('click', () => {
      equationBuilder.exportSession();
    });

    document.getElementById('import-session-btn').addEventListener('click', () => {
      document.getElementById('import-file-input').click();
    });

    // Handle file import
    document.getElementById('import-file-input').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          equationBuilder.importSession(e.target.result);
        };
        reader.readAsText(file);
      }
      // Reset the input so the same file can be selected again
      event.target.value = '';
    });

    document.getElementById('clear-canvas-btn').addEventListener('click', () => {
      if (confirm('Are you sure you want to clear the entire canvas? This cannot be undone.')) {
        equationBuilder.clearCanvas('full');
      }
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
      setTimeout(() => {
        equationBuilder.updateConnections();
      }, 100);
    });
  });
</script>

<style>
  .section {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem 1rem;
    text-align: center;
  }

  /* Base node styling */
  .equation-node {
    position: absolute;
    min-width: 80px;
    padding: 8px 12px;
    background: white;
    border: 2px solid #cbd5e1;
    border-radius: 6px;
    cursor: move;
    user-select: none;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    font-size: 14px;
    font-weight: 500;
    z-index: 10;
    display: block;
    transition: all 0.2s ease;
  }

  .equation-node:hover {
    border-color: #3b82f6;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    transform: translateY(-1px);
  }

  /* Multi-selection styling */
  .equation-node.selected {
    border: 3px solid #3b82f6 !important;
    box-shadow: 
      0 0 0 2px rgba(59, 130, 246, 0.3),
      0 4px 12px rgba(59, 130, 246, 0.2) !important;
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(59, 130, 246, 0.05)) !important;
    transform: scale(1.02) !important;
    z-index: 1000 !important;
  }

  .equation-node.selected::after {
    content: '✓';
    position: absolute;
    top: -8px;
    right: -8px;
    width: 16px;
    height: 16px;
    background: #3b82f6;
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: bold;
    pointer-events: none;
    z-index: 1001;
  }

  .equation-node.selected::before {
    content: '';
    position: absolute;
    top: -5px;
    left: -5px;
    right: -5px;
    bottom: -5px;
    border: 2px dashed #3b82f6;
    border-radius: 8px;
    pointer-events: none;
    animation: dash 2s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: -20px;
    }
  }

  /* Selection rectangle for drag selection */
  .selection-rectangle {
    border: 2px dashed #3b82f6;
    background: rgba(59, 130, 246, 0.1);
    pointer-events: none;
    z-index: 999;
    border-radius: 4px;
    animation: pulse-selection 1s ease-in-out infinite alternate;
  }

  @keyframes pulse-selection {
    from {
      background: rgba(59, 130, 246, 0.1);
      border-color: #3b82f6;
    }
    to {
      background: rgba(59, 130, 246, 0.2);
      border-color: #1d4ed8;
    }
  }

  /* Selection Status Bar */
  .selection-status {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 16px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(59, 130, 246, 0.2);
    border-radius: 12px;
    padding: 8px 16px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    animation: slideInFromTop 0.3s ease-out;
  }

  @keyframes slideInFromTop {
    from {
      opacity: 0;
      transform: translateX(-50%) translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
  }

  .selection-count {
    font-weight: 600;
    color: #3b82f6;
    font-size: 14px;
  }

  .selection-actions {
    display: flex;
    gap: 8px;
  }

  .selection-btn {
    padding: 6px 12px;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    background: white;
    color: #475569;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
  }

  .selection-btn:hover {
    background: #f8fafc;
    border-color: #3b82f6;
    color: #3b82f6;
  }

  .selection-btn.danger {
    color: #dc2626;
    border-color: #fecaca;
  }

  .selection-btn.danger:hover {
    background: #fef2f2;
    border-color: #dc2626;
  }

  /* Group Indicator */
  .group-indicator {
    border: 3px dashed #10b981;
    border-radius: 12px;
    background: rgba(16, 185, 129, 0.1);
    animation: groupPulse 2s ease-in-out infinite;
  }

  .group-indicator::after {
    content: 'Grouped';
    position: absolute;
    top: -30px;
    left: 50%;
    transform: translateX(-50%);
    background: #10b981;
    color: white;
    padding: 4px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 600;
    white-space: nowrap;
  }

  @keyframes groupPulse {
    0%, 100% {
      transform: scale(1);
      opacity: 0.8;
    }
    50% {
      transform: scale(1.02);
      opacity: 1;
    }
  }

  .section h2 {
    font-size: 2.5rem;
    color: #1e293b;
    margin-bottom: 1rem;
  }

  .section p {
    font-size: 1.1rem;
    color: #64748b;
    margin-bottom: 2rem;
  }

  .equation-builder {
    display: flex;
    height: 600px;
    max-width: 1200px;
    margin: 0 auto;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    background: #f8fafc;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  }

  .node-palette {
    width: 200px;
    background: white;
    border-right: 1px solid #e2e8f0;
    padding: 16px;
    overflow-y: auto;
  }

  .node-palette h3 {
    font-size: 16px;
    font-weight: 600;
    color: #1e293b;
    margin-bottom: 16px;
  }

  .palette-section {
    margin-bottom: 20px;
  }

  .palette-section h4 {
    font-size: 14px;
    font-weight: 500;
    color: #475569;
    margin-bottom: 8px;
  }

  :global(.palette-node) {
    display: block !important;
    width: 100% !important;
    padding: 10px 15px !important;
    margin-bottom: 8px !important;
    background: #3b82f6 !important;
    color: white !important;
    border: none !important;
    border-radius: 8px !important;
    font-size: 14px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    text-align: center !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
  }

  :global(.palette-node:hover) {
    transform: translateY(-2px) !important;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4) !important;
    background: #2563eb !important;
  }

  :global(.palette-node:active) {
    transform: translateY(0px) !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2) !important;
  }

  :global(.page-title) {
    font-weight: 700 !important;
    font-size: 18px !important;
    color: #1e40af !important;
    margin-bottom: 16px !important;
    padding: 12px 0 !important;
    text-align: center !important;
    border-bottom: 3px solid #3b82f6 !important;
    text-transform: uppercase !important;
    letter-spacing: 0.5px !important;
  }

  :global(.palette-nav) {
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    margin-bottom: 16px !important;
    padding: 8px 0 !important;
  }

  :global(.nav-btn) {
    padding: 8px 16px !important;
    background: #f8fafc !important;
    border: 2px solid #e2e8f0 !important;
    border-radius: 6px !important;
    cursor: pointer !important;
    font-weight: 500 !important;
    color: #475569 !important;
    transition: all 0.2s !important;
  }

  :global(.nav-btn:hover) {
    background: #667eea !important;
    border-color: #667eea !important;
    color: white !important;
    transform: translateY(-1px) !important;
  }

  :global(.nav-btn:disabled) {
    opacity: 0.5 !important;
    cursor: not-allowed !important;
    transform: none !important;
  }

  :global(.page-indicator) {
    font-weight: 600 !important;
    color: #374151 !important;
    background: #f1f5f9 !important;
    padding: 6px 12px !important;
    border-radius: 20px !important;
    font-size: 12px !important;
  }

  :global(.page-btn) {
    padding: 8px 12px !important;
    background: #f8fafc !important;
    border: 2px solid #e2e8f0 !important;
    border-radius: 6px !important;
    cursor: pointer !important;
    font-weight: 600 !important;
    color: #475569 !important;
    font-size: 16px !important;
    transition: all 0.2s !important;
    width: 40px !important;
    height: 36px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
  }

  :global(.page-btn:hover) {
    background: #3b82f6 !important;
    border-color: #3b82f6 !important;
    color: white !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3) !important;
  }

  :global(.page-btn:disabled) {
    opacity: 0.4 !important;
    cursor: not-allowed !important;
    transform: none !important;
    background: #f1f5f9 !important;
    border-color: #e2e8f0 !important;
  }

  :global(.page-controls) {
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    margin-bottom: 16px !important;
    padding: 8px !important;
    background: #ffffff !important;
    border-radius: 8px !important;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
  }

  :global(.component-edit-btn) {
    background: #f59e0b !important;
    border: none !important;
    border-radius: 4px !important;
    color: white !important;
    cursor: pointer !important;
    font-size: 12px !important;
    margin-left: 8px !important;
    padding: 4px 6px !important;
    transition: all 0.2s !important;
  }

  :global(.component-edit-btn:hover) {
    background: #d97706 !important;
    transform: scale(1.1) !important;
  }

  :global(.node-component) {
    background: #6366f1 !important;
    color: white !important;
  }

  :global(.node-conditional) {
    background: #8b5cf6 !important;
    color: white !important;
    border: 2px solid #7c3aed !important;
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3) !important;
  }
  
  :global(.node-conditional:hover) {
    transform: translateY(-2px) !important;
    box-shadow: 0 6px 16px rgba(139, 92, 246, 0.4) !important;
  }

  :global(.node-component-input) {
    background: #10b981 !important;
    color: white !important;
    border: 2px solid #059669 !important;
    font-weight: 600 !important;
  }

  :global(.node-component-output) {
    background: #f59e0b !important;
    color: white !important;
    border: 2px solid #d97706 !important;
    font-weight: 600 !important;
  }

  :global(.node-multiplexer) {
    background: #14b8a6 !important;
    color: white !important;
    border: 2px solid #0d9488 !important;
    box-shadow: 0 4px 12px rgba(20, 184, 166, 0.3) !important;
  }
  
  :global(.node-multiplexer:hover) {
    transform: translateY(-2px) !important;
    box-shadow: 0 6px 16px rgba(20, 184, 166, 0.4) !important;
  }

  :global(.node-splitter) {
    background: #f97316 !important;
    color: white !important;
    border: 2px solid #ea580c !important;
    box-shadow: 0 4px 12px rgba(249, 115, 22, 0.3) !important;
  }
  
  :global(.node-splitter:hover) {
    transform: translateY(-2px) !important;
    box-shadow: 0 6px 16px rgba(249, 115, 22, 0.4) !important;
  }

  .canvas {
    flex: 1;
    position: relative;
    overflow: visible;
    background: linear-gradient(
      to right,
      rgba(148, 163, 184, 0.1) 1px,
      transparent 1px
    ),
    linear-gradient(
      to bottom,
      rgba(148, 163, 184, 0.1) 1px,
      transparent 1px
    );
    background-size: 20px 20px;
  }

  /* Global styles for dynamically created elements */
  :global(.node) {
    position: absolute;
    min-width: 80px;
    padding: 8px 12px;
    background: white;
    border: 2px solid #cbd5e1;
    border-radius: 6px;
    cursor: move;
    user-select: none;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: all 0.2s;
    font-size: 14px;
    font-weight: 500;
    z-index: 10;
  }

  :global(.node:hover) {
    border-color: #3b82f6;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
  }

  :global(.equation-node.selected) {
    border-color: #3b82f6 !important;
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(59, 130, 246, 0.05)) !important;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3), 0 4px 12px rgba(59, 130, 246, 0.2) !important;
  }

  :global(.node-number), :global(.node-variable) {
    border-color: #10b981;
    background: #f0fdf4;
  }

  :global(.node-add), :global(.node-subtract), :global(.node-multiply), :global(.node-divide), :global(.node-power) {
    border-color: #f59e0b;
    background: #fffbeb;
  }

  :global(.node-output) {
    border-color: #8b5cf6;
    background: #faf5ff;
  }

  :global(.port) {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #3b82f6;
    border: 2px solid white;
    border-radius: 50%;
    cursor: crosshair;
    z-index: 20;
    transition: all 0.2s;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
  }

  :global(.input-port) {
    left: -7px;
    background: #10b981;
  }

  :global(.output-port) {
    right: -7px;
    background: #f59e0b;
  }

  :global(.port:hover) {
    transform: scale(1.4);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
  }

  :global(.input-port:hover) {
    background: #059669;
  }

  :global(.output-port:hover) {
    background: #d97706;
  }

  @keyframes pulse {
    0%, 100% {
      transform: scale(1.4);
      opacity: 1;
    }
    50% {
      transform: scale(1.6);
      opacity: 0.8;
    }
  }

  .connections {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 5;
    opacity: 1;
    visibility: visible;
    display: block;
  }

  :global(.connections path) {
    pointer-events: stroke;
    stroke-width: 3px;
    stroke: #3b82f6;
  }

  :global(.connections path:hover) {
    stroke: #1d4ed8 !important;
    stroke-width: 3;
  }

  :global(.node-content) {
    pointer-events: none;
  }

  .equation-display {
    position: absolute;
    bottom: 16px;
    left: 16px;
    right: 16px;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    padding: 12px;
    font-family: 'Courier New', monospace;
    font-size: 16px;
    min-height: 40px;
    display: flex;
    align-items: center;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .sidebar {
    position: fixed;
    top: 0;
    right: -300px;
    width: 300px;
    height: 100vh;
    background: white;
    border-left: 1px solid #e2e8f0;
    box-shadow: -4px 0 8px rgba(0, 0, 0, 0.1);
    transition: right 0.3s ease;
    z-index: 1001;
    padding: 20px;
    overflow-y: auto;
  }

  .sidebar.open {
    right: 0;
  }

  .sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 12px;
    border-bottom: 1px solid #e2e8f0;
  }

  .sidebar-header h3 {
    font-size: 18px;
    font-weight: 600;
    color: #1e293b;
  }

  .close-btn {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: #64748b;
    padding: 4px;
    border-radius: 4px;
  }

  .close-btn:hover {
    background: #f1f5f9;
    color: #1e293b;
  }

  /* Tables Sidebar */
  .tables-sidebar {
    position: fixed;
    top: 0;
    left: 0;
    width: 380px;
    height: 100vh;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-right: 2px solid #e5e7eb;
    box-shadow: 4px 0 20px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    transform: translateX(-100%);
    transition: transform 0.3s ease;
    overflow-y: auto;
    display: none;
  }

  .tables-sidebar.open {
    display: block;
    transform: translateX(0);
  }

  .tables-sidebar-header {
    background: #f3f4f6;
    padding: 16px;
    border-bottom: 2px solid #e5e7eb;
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: sticky;
    top: 0;
    z-index: 10;
  }

  .tables-sidebar-header h3 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    color: #374151;
  }

  .table-section {
    border-bottom: 1px solid #f3f4f6;
  }

  .section-header {
    background: #f9fafb;
    padding: 12px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    border-bottom: 1px solid #e5e7eb;
  }

  .section-header:hover {
    background: #f3f4f6;
  }

  .section-header h4 {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
    color: #374151;
  }

  .section-toggle {
    background: none;
    border: none;
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    color: #6b7280;
    transition: all 0.2s;
  }

  .section-toggle:hover {
    background: #e5e7eb;
    color: #374151;
  }

  .section-content {
    padding: 0;
    overflow: hidden;
    transition: max-height 0.3s ease;
  }

  .section-content.collapsed {
    max-height: 0;
  }

  .variables-table, .equations-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
  }

  .variables-table th, .equations-table th {
    background: #f9fafb;
    padding: 12px;
    text-align: left;
    font-weight: 600;
    color: #374151;
    border-bottom: 2px solid #e5e7eb;
    position: sticky;
    top: 0;
  }

  .variables-table td, .equations-table td {
    padding: 12px;
    border-bottom: 1px solid #f3f4f6;
    vertical-align: top;
  }

  /* Ensure name column in equations table is top-aligned */
  .equations-table td:first-child {
    vertical-align: top;
  }

  .variables-table tr:hover, .equations-table tr:hover {
    background: #f9fafb;
  }

  .latex-cell {
    font-family: 'KaTeX_Main', 'Times New Roman', serif;
    font-size: 16px;
  }

  /* Equation Builder Toolbar */
  .equation-toolbar {
    width: 100%;
    max-width: 1200px;
    margin: 0 auto 20px auto;
    height: 60px;
    background: linear-gradient(to right, #f8fafc, #f1f5f9);
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 0 20px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .toolbar-btn {
    background: #374151;
    color: white;
    border: none;
    padding: 10px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .toolbar-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
  }

  .toolbar-btn:first-child {
    background: #3b82f6;
  }

  .toolbar-btn:first-child:hover {
    background: #2563eb;
  }

  .export-btn:hover { background: #059669; }
  .import-btn:hover { background: #0d9488; }
  .clear-btn:hover { background: #dc2626; }

  .toolbar-divider {
    width: 1px;
    height: 30px;
    background: #d1d5db;
    margin: 0 8px;
  }

  .auto-save-indicator {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 12px;
    background: rgba(34, 197, 94, 0.1);
    border-radius: 6px;
    opacity: 0;
    transition: opacity 0.3s;
    margin-left: auto;
  }

  .auto-save-indicator.show {
    opacity: 1;
  }

  .auto-save-dot {
    width: 8px;
    height: 8px;
    background: #22c55e;
    border-radius: 50%;
    animation: pulse 2s infinite;
  }

  .auto-save-text {
    font-size: 12px;
    color: #166534;
    font-weight: 500;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  /* Remove the content offset since toolbar is now relative */
  .section {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem 1rem;
    text-align: center;
  }

  .input-group {
    margin-bottom: 16px;
  }

  .input-group label {
    display: block;
    font-size: 14px;
    font-weight: 500;
    color: #374151;
    margin-bottom: 6px;
  }

  .input-group input {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #d1d5db;
    border-radius: 4px;
    font-size: 14px;
  }

  .input-group input:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  .delete-btn {
    background: #ef4444;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    margin-top: 12px;
    width: 100%;
  }

  .delete-btn:hover {
    background: #dc2626;
  }
  /* Palette Footer */
  .palette-footer {
    padding: 12px;
    border-top: 1px solid #e5e7eb;
    margin-top: auto;
  }

  /* Help Button */
  .help-button {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: #3b82f6;
    color: white;
    border: none;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto;
  }

  .help-button:hover {
    background: #2563eb;
    transform: scale(1.05);
  }

  /* Help Modal */
  .help-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.5);
    display: none;
    z-index: 1001;
    overflow-y: auto;
  }

  .help-modal.active {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
  }

  .help-content {
    background: white;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    max-width: 800px;
    width: 100%;
    max-height: 80vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .help-header {
    padding: 20px 24px;
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    border-radius: 12px 12px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .help-header h2 {
    margin: 0;
    font-size: 1.5rem;
    font-weight: 600;
    color: #1e293b;
  }

  .help-nav {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .help-page-controls {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .help-page-btn {
    padding: 4px 8px;
    background: #e2e8f0;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    color: #475569;
  }

  .help-page-btn:hover {
    background: #cbd5e1;
  }

  .help-page-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .help-page-indicator {
    font-size: 14px;
    color: #64748b;
    min-width: 50px;
    text-align: center;
  }

  .help-body {
    padding: 24px;
    overflow-y: auto;
    line-height: 1.6;
  }

  .help-section {
    margin-bottom: 32px;
  }

  .help-section h3 {
    color: #374151;
    margin: 0 0 16px 0;
    font-size: 1.2rem;
    font-weight: 600;
    border-bottom: 2px solid #e5e7eb;
    padding-bottom: 8px;
  }

  .node-family {
    margin-bottom: 24px;
    padding: 16px;
    background: #f9fafb;
    border-radius: 8px;
    border-left: 4px solid #6366f1;
  }

  .node-family h4 {
    margin: 0 0 12px 0;
    color: #4f46e5;
    font-size: 1.1rem;
    font-weight: 600;
  }

  .node-family p {
    margin: 0 0 8px 0;
    color: #6b7280;
  }

  .node-list {
    list-style: none;
    padding: 0;
    margin: 8px 0 0 0;
  }

  .node-list li {
    padding: 4px 0;
    color: #374151;
    font-family: 'Monaco', 'Consolas', monospace;
    font-size: 0.9rem;
  }

  .node-list li::before {
    content: "→ ";
    color: #6366f1;
    font-weight: bold;
    margin-right: 8px;
  }

  .help-tip {
    background: #f0f9ff;
    border: 1px solid #0ea5e9;
    border-radius: 6px;
    padding: 12px;
    margin: 16px 0;
  }

  .help-tip strong {
    color: #0c4a6e;
  }

  /* Close button for help modal */
  .help-header .close-btn {
    background: #e2e8f0;
    color: #475569;
    border: 1px solid #cbd5e1;
  }

  .help-header .close-btn:hover {
    background: #cbd5e1;
  }

  /* Enhanced interaction styles */
  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.6; }
    100% { opacity: 1; }
  }

  /* Node selection menu styles */
  #node-selection-menu {
    font-family: system-ui, -apple-system, sans-serif;
  }

  #node-selection-menu .menu-node-item:hover {
    background-color: #f3f4f6 !important;
    transform: translateX(2px);
  }

  /* Enhanced palette button hover states for drag indication */
  .palette-node {
    transition: all 0.2s ease;
    position: relative;
  }

  .palette-node:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  }

  .palette-node:active {
    transform: translateY(0);
  }

  /* Canvas drop zone highlighting */
  .canvas-drop-active {
    background: rgba(59, 130, 246, 0.1) !important;
    border: 2px dashed #3b82f6 !important;
  }

  /* Connection drag feedback */
  .connection-drag-active .input-port {
    animation: pulse 1s infinite;
    box-shadow: 0 0 10px rgba(16, 185, 129, 0.6) !important;
  }

  /* Improved port hover states */
  .port {
    transition: all 0.2s ease;
  }

  .port:hover {
    transform: scale(1.4) !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4) !important;
  }

  /* Dragging cursor states */
  body.dragging-connection {
    cursor: crosshair !important;
  }

  body.dragging-node {
    cursor: grabbing !important;
  }

  /* Visual feedback for drag operations */
  .drag-ghost {
    pointer-events: none;
    opacity: 0.7;
    transform: rotate(3deg);
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }
</style>
